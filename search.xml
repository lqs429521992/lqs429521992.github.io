<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Pensieve 集群搭建</title>
      <link href="2021/10/10/pensieve-ji-qun-da-jian/"/>
      <url>2021/10/10/pensieve-ji-qun-da-jian/</url>
      
        <content type="html"><![CDATA[<h2 id="机房搭建"><a href="#机房搭建" class="headerlink" title="机房搭建"></a>机房搭建</h2><p><img src="/images/cluster_picture.jpg" alt="机房图片"></p><h3 id="硬件设备"><a href="#硬件设备" class="headerlink" title="硬件设备"></a>硬件设备</h3><ul><li>主机5台</li><li>树莓派2台</li><li>笔记本1台</li><li>交换机1台</li><li>UPS一台</li><li>开机棒一个</li></ul><h2 id="系统安装"><a href="#系统安装" class="headerlink" title="系统安装"></a>系统安装</h2><h3 id="Ubuntu"><a href="#Ubuntu" class="headerlink" title="Ubuntu"></a>Ubuntu</h3><h4 id="U盘制作"><a href="#U盘制作" class="headerlink" title="U盘制作"></a>U盘制作</h4><ul><li>准备工作<ol><li><a href="https://ubuntu.com/download/desktop">Ubuntu-20.04.3</a></li><li><a href="https://www.jb51.net/softs/44650.html">UltraISO</a></li></ol></li><li>制作启动盘<ol><li>写入硬盘映像<br><img src="/images/write_to_hard_disk_image.png" alt="写入硬盘映像"></li><li>选择写入硬盘<br><img src="/images/select_hard_disk.png" alt="选择硬盘"></li></ol></li></ul><h4 id="LVM-磁盘"><a href="#LVM-磁盘" class="headerlink" title="LVM 磁盘"></a>LVM 磁盘</h4><p>安装系统时，为便于之后维护，请使用 LVM 安装Ubuntu。</p><blockquote><p>具体LVM相关 请参考本网站相关文章：<a href="https://www.kinson.fun/2021/06/15/lvm-xue-xi-bi-ji/">LVM学习笔记</a>。</p></blockquote><p><img src="/images/use_lvm_install.png" alt="选择硬盘"></p><h2 id="集群搭建"><a href="#集群搭建" class="headerlink" title="集群搭建"></a>集群搭建</h2><h3 id="基础环境"><a href="#基础环境" class="headerlink" title="基础环境"></a>基础环境</h3><h3 id="K3S"><a href="#K3S" class="headerlink" title="K3S"></a>K3S</h3><h4 id="Master"><a href="#Master" class="headerlink" title="Master"></a>Master</h4><p><strong>安装脚本：</strong></p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">curl -sfL http://rancher-mirror.cnrancher.com/k3s/k3s-install.sh | INSTALL_K3S_MIRROR=cn sh -<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>运行此安装后：</p><ol><li>K3s 服务将被配置为在节点重启后或进程崩溃或被杀死时自动重启。</li><li>将安装其他实用程序，包括<code>kubectl、crictl、ctr、k3s-killall.sh</code> 和 <code>k3s-uninstall.sh</code>。</li><li>将kubeconfig文件写入到/etc/rancher/k3s/k3s.yaml，由 K3s 安装的 kubectl 将自动使用该文件</li></ol><h4 id="Node"><a href="#Node" class="headerlink" title="Node"></a>Node</h4><p><strong>安装脚本：</strong></p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">curl -sfL http://rancher-mirror.cnrancher.com/k3s/k3s-install.sh | INSTALL_K3S_MIRROR=cn K3S_URL=https://myserver:6443 K3S_TOKEN=mynodetoken sh -<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>设置<code>K3S_URL</code>参数会使 K3s 以 worker 模式运行。K3s agent 将在所提供的 URL 上向监听的 K3s 服务器注册。</li><li><code>K3S_TOKEN</code>存储在你的服务器<code>/var/lib/rancher/k3s/server/node-token</code>下<blockquote><p>每台计算机必须具有唯一的主机名。如果您的计算机没有唯一的主机名，请传递K3S_NODE_NAME环境变量，并为每个节点提供一个有效且唯一的主机名。</p></blockquote></li></ul><h4 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h4><p>执行 <code>kubectl get nodes</code> 获取节点信息<br><img src="/images/cluster_success.png" alt="节点信息"></p><h3 id="longhorn"><a href="#longhorn" class="headerlink" title="longhorn"></a>longhorn</h3><h4 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h4><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">apt install open-iscsi jq curl util-linux -yapt-get install nfs-common -y<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><pre class="line-numbers language-none"><code class="language-none">kubectl apply -f https://raw.githubusercontent.com/longhorn/longhorn/master/deploy/longhorn.yaml<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="Helm"><a href="#Helm" class="headerlink" title="Helm"></a>Helm</h3><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">curl https://baltocdn.com/helm/signing.asc | sudo apt-key add -sudo apt-get install apt-transport-https --yesecho "deb https://baltocdn.com/helm/stable/debian/ all main" | sudo tee /etc/apt/sources.list.d/helm-stable-debian.listsudo apt-get updatesudo apt-get install helm<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="Rancher"><a href="#Rancher" class="headerlink" title="Rancher"></a>Rancher</h3><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">helm repo add rancher-stable https://releases.rancher.com/server-charts/stablekubectl create namespace cattle-systemhelm install rancher rancher-stable/rancher --namespace cattle-system --set hostname=rancher.kinson.fun --set ingress.tls.source=secretcp /etc/rancher/k3s/k3s.yaml ~/.kube/config<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h2 id="应用安装"><a href="#应用安装" class="headerlink" title="应用安装"></a>应用安装</h2><h3 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h3><p>因为Kubernetes 从v1.20后不再使用 使用 Containerd 替代 Docker，作为默认的容器运行时(CRI)<br>但 Containerd没有构建镜像的功能，因此如果需要构建镜像的话，仍需安装Docker</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">curl -fsSL https://get.docker.com | bash -s docker --mirror Aliyun<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 部署 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Pensieve </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker配置文件详解</title>
      <link href="2021/07/07/docker-pei-zhi-wen-jian-xiang-jie/"/>
      <url>2021/07/07/docker-pei-zhi-wen-jian-xiang-jie/</url>
      
        <content type="html"><![CDATA[<h2 id="daemon-json"><a href="#daemon-json" class="headerlink" title="daemon.json"></a>daemon.json</h2><p>Docker Engine V1.12 之后版本，用户可以自行创建 daemon.json 文件对 Docker Engine 进行配置和调整。</p><p>要点如下：</p><ul><li>该文件作为 Docker Engine 的配置管理文件, 里面几乎涵盖了所有 docker 命令行启动可以配置的参数。</li><li>不管是在哪个平台以何种方式启动, Docker 默认都会来这里读取配置。</li><li>用户可以统一管理不同系统下的 docker daemon 配置。</li><li>相关参数的使用说明，可以参阅 <code>man dockerd</code> 帮助信息，或者参阅<a href="https://docs.docker.com/engine/reference/commandline/dockerd/#daemon">官方文档</a>。</li></ul><p>配置详解</p><pre class="line-numbers language-json" data-language="json"><code class="language-json"><span class="token punctuation">{</span>    <span class="token property">"api-cors-header"</span><span class="token operator">:</span> <span class="token string">""</span><span class="token punctuation">,</span> <span class="token comment">//在引擎API中设置CORS标头</span>    <span class="token property">"authorization-plugins"</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token comment">//要加载的授权插件</span>    <span class="token property">"bridge"</span><span class="token operator">:</span> <span class="token string">""</span><span class="token punctuation">,</span> <span class="token comment">//将容器附加到网桥</span>    <span class="token property">"cgroup-parent"</span><span class="token operator">:</span> <span class="token string">""</span><span class="token punctuation">,</span> <span class="token comment">//为所有容器设置父cgroup</span>    <span class="token property">"cluster-store"</span><span class="token operator">:</span> <span class="token string">""</span><span class="token punctuation">,</span> <span class="token comment">//分布式存储后端的URL</span>    <span class="token property">"cluster-store-opts"</span><span class="token operator">:</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token comment">//——设置集群存储选项（默认map []）</span>    <span class="token property">"cluster-advertise"</span><span class="token operator">:</span> <span class="token string">""</span><span class="token punctuation">,</span> <span class="token comment">//——要通告的地址或接口名称</span>    <span class="token property">"debug"</span><span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span> <span class="token comment">//——启用调试模式，启用后，可以看到很多的启动信息。默认false</span>    <span class="token property">"default-gateway"</span><span class="token operator">:</span> <span class="token string">""</span><span class="token punctuation">,</span> <span class="token comment">//容器默认网关IPv4地址</span>    <span class="token property">"default-gateway-v6"</span><span class="token operator">:</span> <span class="token string">""</span><span class="token punctuation">,</span> <span class="token comment">//容器默认网关IPv6地址</span>    <span class="token property">"default-runtime"</span><span class="token operator">:</span> <span class="token string">"runc"</span><span class="token punctuation">,</span> <span class="token comment">//——容器的默认OCI运行时（默认为" runc"）</span>    <span class="token property">"default-ulimits"</span><span class="token operator">:</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token comment">//容器的默认ulimit（默认[]）</span>    <span class="token property">"dns"</span><span class="token operator">:</span> <span class="token punctuation">[</span>        <span class="token string">"192.168.1.1"</span>    <span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token comment">//设定容器DNS的地址，在容器的 /etc/resolv.conf文件中可查看。</span>    <span class="token property">"dns-opts"</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token comment">//——容器 /etc/resolv.conf 文件，其他设置</span>    <span class="token property">"dns-search"</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token comment">//——设定容器的搜索域，当设定搜索域为 .example.com 时，在搜索一个名为 host 的 主机时，DNS不仅搜索host，还会搜索host.example.com 。 注意：如果不设置， Docker 会默认用主机上的 /etc/resolv.conf 来配置容器。</span>    <span class="token property">"exec-opts"</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token comment">//——运行时执行选项</span>    <span class="token property">"exec-root"</span><span class="token operator">:</span> <span class="token string">""</span><span class="token punctuation">,</span> <span class="token comment">//——执行状态文件的根目录（默认为’/var/run/docker‘）</span>    <span class="token property">"fixed-cidr"</span><span class="token operator">:</span> <span class="token string">""</span><span class="token punctuation">,</span> <span class="token comment">//——固定IP的IPv4子网</span>    <span class="token property">"fixed-cidr-v6"</span><span class="token operator">:</span> <span class="token string">""</span><span class="token punctuation">,</span> <span class="token comment">//——固定IP的IPv6子网</span>    <span class="token property">"data-root"</span><span class="token operator">:</span> <span class="token string">"/var/lib/docker"</span><span class="token punctuation">,</span> <span class="token comment">//Docker运行时使用的根路径，默认/var/lib/docker</span>    <span class="token property">"group"</span><span class="token operator">:</span> <span class="token string">""</span><span class="token punctuation">,</span> <span class="token comment">//UNIX套接字的组（默认为"docker"）</span>    <span class="token property">"hosts"</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token comment">//设置容器hosts</span>    <span class="token property">"icc"</span><span class="token operator">:</span> <span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token comment">//启用容器间通信（默认为true）</span>    <span class="token property">"ip"</span><span class="token operator">:</span> <span class="token string">"0.0.0.0"</span><span class="token punctuation">,</span> <span class="token comment">//——绑定容器端口时的默认IP（默认0.0.0.0）</span>    <span class="token property">"iptables"</span><span class="token operator">:</span> <span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token comment">//—启用iptables规则添加（默认为true）</span>    <span class="token property">"ipv6"</span><span class="token operator">:</span> <span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token comment">//启用IPv6网络</span>    <span class="token property">"ip-forward"</span><span class="token operator">:</span> <span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token comment">//——默认true, 启用 net.ipv4.ip_forward ,进入容器后使用 sysctl -a | grepnet.ipv4.ip_forward 查看</span>    <span class="token property">"ip-masq"</span><span class="token operator">:</span> <span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token comment">//启用IP伪装（默认为true）</span>    <span class="token property">"labels"</span><span class="token operator">:</span> <span class="token punctuation">[</span>        <span class="token string">"nodeName=node-121"</span>    <span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token comment">//——docker主机的标签，很实用的功能,例如定义：–label nodeName=host-121</span>    <span class="token property">"live-restore"</span><span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span> <span class="token comment">//在容器仍在运行时启用docker的实时还原</span>    <span class="token property">"log-driver"</span><span class="token operator">:</span> <span class="token string">""</span><span class="token punctuation">,</span> <span class="token comment">//容器日志的默认驱动程序（默认为" json-file"）</span>    <span class="token property">"log-level"</span><span class="token operator">:</span> <span class="token string">""</span><span class="token punctuation">,</span> <span class="token comment">//设置日志记录级别（"调试"，"信息"，"警告"，"错误"，"致命"）（默认为"信息"）</span>    <span class="token property">"max-concurrent-downloads"</span><span class="token operator">:</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token comment">//设置每个请求的最大并发下载量（默认为3）</span>    <span class="token property">"max-concurrent-uploads"</span><span class="token operator">:</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token comment">//设置每次推送的最大同时上传数（默认为5）</span>    <span class="token property">"mtu"</span><span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token comment">//设置容器网络MTU</span>    <span class="token property">"oom-score-adjust"</span><span class="token operator">:</span> <span class="token number">-500</span><span class="token punctuation">,</span> <span class="token comment">//设置守护程序的oom_score_adj（默认值为-500）</span>    <span class="token property">"pidfile"</span><span class="token operator">:</span> <span class="token string">""</span><span class="token punctuation">,</span> <span class="token comment">//Docker守护进程的PID文件</span>    <span class="token property">"raw-logs"</span><span class="token operator">:</span> <span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token comment">//全时间戳机制</span>    <span class="token property">"selinux-enabled"</span><span class="token operator">:</span> <span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token comment">//默认 false，启用selinux支持</span>    <span class="token property">"storage-driver"</span><span class="token operator">:</span> <span class="token string">""</span><span class="token punctuation">,</span> <span class="token comment">//要使用的存储驱动程序</span>    <span class="token property">"swarm-default-advertise-addr"</span><span class="token operator">:</span> <span class="token string">""</span><span class="token punctuation">,</span> <span class="token comment">//设置默认地址或群集广告地址的接口</span>    <span class="token property">"tls"</span><span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span> <span class="token comment">//——默认 false, 启动TLS认证开关</span>    <span class="token property">"tlscacert"</span><span class="token operator">:</span> <span class="token string">""</span><span class="token punctuation">,</span> <span class="token comment">//默认 ~/.docker/ca.pem，通过CA认证过的的certificate文件路径</span>    <span class="token property">"tlscert"</span><span class="token operator">:</span> <span class="token string">""</span><span class="token punctuation">,</span> <span class="token comment">//——默认 ~/.docker/cert.pem ，TLS的certificate文件路径</span>    <span class="token property">"tlskey"</span><span class="token operator">:</span> <span class="token string">""</span><span class="token punctuation">,</span> <span class="token comment">//——默认~/.docker/key.pem，TLS的key文件路径</span>    <span class="token property">"tlsverify"</span><span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span> <span class="token comment">//——默认false，使用TLS并做后台进程与客户端通讯的验证</span>    <span class="token property">"userland-proxy"</span><span class="token operator">:</span> <span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token comment">//使用userland代理进行环回流量（默认为true）</span>    <span class="token property">"userns-remap"</span><span class="token operator">:</span> <span class="token string">""</span><span class="token punctuation">,</span> <span class="token comment">//——用户名称空间的用户/组设置</span>    <span class="token property">"bip"</span><span class="token operator">:</span> <span class="token string">"192.168.88.0/22"</span><span class="token punctuation">,</span> <span class="token comment">//————指定网桥IP</span>    <span class="token property">"registry-mirrors"</span><span class="token operator">:</span> <span class="token punctuation">[</span>        <span class="token string">"https://192.498.89.232:89"</span>    <span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token comment">//——设置镜像加速</span>    <span class="token property">"insecure-registries"</span><span class="token operator">:</span> <span class="token punctuation">[</span>        <span class="token string">"120.123.122.123:12312"</span>    <span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token comment">//—设置私有仓库地址可以设为http</span>    <span class="token property">"storage-opts"</span><span class="token operator">:</span> <span class="token punctuation">[</span>        <span class="token string">"overlay2.override_kernel_check=true"</span><span class="token punctuation">,</span>        <span class="token string">"overlay2.size=15G"</span>    <span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token comment">//——存储驱动程序选项</span>    <span class="token property">"log-opts"</span><span class="token operator">:</span> <span class="token punctuation">{</span>        <span class="token property">"max-file"</span><span class="token operator">:</span> <span class="token string">"3"</span><span class="token punctuation">,</span>        <span class="token property">"max-size"</span><span class="token operator">:</span> <span class="token string">"10m"</span>    <span class="token punctuation">}</span> <span class="token comment">//——容器默认日志驱动程序选项</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker配置 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>进程、线程、协程</title>
      <link href="2021/07/06/jin-cheng-xian-cheng-xie-cheng/"/>
      <url>2021/07/06/jin-cheng-xian-cheng-xie-cheng/</url>
      
        <content type="html"><![CDATA[<h2 id="总述"><a href="#总述" class="headerlink" title="总述"></a>总述</h2><p>首先来一句概括的总论：进程和线程都是对一个时间段的描述，对CPU工作时间段的描述。</p><p>我们的电脑是由 CPU + RAM + 各种资源（比如显卡，光驱，键盘，GPS，等等）构成的，但是电脑的运行，归根结底只是CPU和相关寄存器，以及RAM之间的事情。</p><h3 id="关于CPU"><a href="#关于CPU" class="headerlink" title="关于CPU"></a>关于CPU</h3><p>CPU太快，太快，太快了，寄存器仅仅能够追的上他的脚步，RAM和别的挂在各总线上的设备完全是望其项背。那当多个任务要执行的时候怎么办呢？轮流着来?或者谁优先级高谁来？不管怎么样的策略，一句话就是在CPU看来就是轮流着来。</p><h3 id="关于程序"><a href="#关于程序" class="headerlink" title="关于程序"></a>关于程序</h3><p>当程序执行中得到CPU的时候，相关的资源必须也已经就位，就是显卡啊什么的必须就位，然后CPU开始执行。这里除了CPU，以外的所有就构成了这个程序的执行环境，也就是我们所定义的程序上下文。当这个程序执行完了，或者分配给他的CPU执行时间用完了，那它就要被切换出去，等待下一次CPU的临幸。在被切换出去的最后一步工作就是保存程序上下文，因为这个是下次他被CPU临幸的运行环境，必须保存。</p><h3 id="程序调度"><a href="#程序调度" class="headerlink" title="程序调度"></a>程序调度</h3><p>前面讲过在CPU看来，所有的程序都是一个一个轮流执行的，具体的轮流方法是：先加载程序A的上下文，然后开始执行A，保存程序A的上下文，调入下一个要执行的程序B的程序上下文，然后开始执行B,保存程序B的上下文。如此循环往复……</p><h3 id="进程和线程"><a href="#进程和线程" class="headerlink" title="进程和线程"></a>进程和线程</h3><p>进程和线程，就是在这样的背景之下诞生的。</p><p>进程就是包换上下文切换的程序执行时间总和 = CPU加载上下文 + CPU执行 + CPU保存上下文</p><p>那么线程是什么呢？进程的颗粒度太大，每次都要有上下的调入，保存，调出。如果我们把进程比喻为一个运行在电脑上的软件，那么一个软件的执行不可能是一条逻辑执行的，必定有多个分支和多个程序段，就好比要实现程序A，实际分成 a，b，c等多个块组合而成。那么这里具体的执行就可能变成：</p><ol><li> 程序A得到CPU</li><li> CPU加载上下文</li><li> 执行A的a小段</li><li> 执行A的b小段</li><li> 执行A的c小段</li><li> CPU保存A的上下文</li></ol><p>这里a，b，c的执行是共享了A的上下文，CPU在执行的时候没有进行上下文切换的。这里的a，b，c就是线程，也就是说线程是共享了进程的上下文环境，的更为细小的CPU时间段。</p><h2 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h2><p>进程是在系统中能独立运行并作为资源分配的基本单位，它是由一组机器指令、数据和堆栈等组成的，是一个能独立运行的活动实体。</p><p>注意：进程一般有三个状态,<code>就绪状态</code>、<code>执行状态</code>和<code>等待状态</code>(或称<code>阻塞状态</code>)。进程只能由父进程建立，系统中所有的进程形成一种进程树的层次体系。挂起命令可由进程自己和其他进程发出，但是解除挂起命令只能由其他进程发出。</p><h3 id="进程控制块（PCB）"><a href="#进程控制块（PCB）" class="headerlink" title="进程控制块（PCB）"></a>进程控制块（PCB）</h3><p>PCB不但可以记录进程的属性信息，以便操作系统对进程进行控制和管理，而且PCB标志着进程的存在，操作系统根据系统中是否有该进程的进程控制块PCB而知道该进程存在与否。系统建立进程的同时就建立该进程的PCB，在撤销一个进程时，也就撤销其PCB，故进程的PCB对进程来说是它存在的具体的物理标志和体现。</p><p>一般PCB包括以下三类信息：<code>进程标识信息</code>，<code>处理器状态信息</code>，<code>进程控制信息</code>。</p><p>由程序段、相关的数据段和PCB三部分构成了进程实体（又称进程印像），一般，我们把进程实体就简称为进程。</p><h3 id="进程的特征"><a href="#进程的特征" class="headerlink" title="进程的特征"></a>进程的特征</h3><ol><li> 动态性：  进程的实质是程序的一次执行过程，进程是动态产生，动态消亡的。</li><li> 并发性：  任何进程都可以同其他进程一起并发执行。</li><li> 独立性：  进程是一个能独立运行的基本单位，同时也是系统分配资源和调度的独立单位。</li><li> 异步性：  由于进程间的相互制约，使进程具有执行的间断性，即进程按各自独立的、不可预知的速度向前推进。</li></ol><h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><p>线程是进程中的一个实体，作为系统调度和分派的基本单位。 Linux 下的线程看作轻量级进程。</p><h3 id="线程的性质"><a href="#线程的性质" class="headerlink" title="线程的性质"></a>线程的性质</h3><ol><li> 线程是进程内的一个相对独立的可执行的单元。若把进程称为任务的话，那么线程则是应用中的一个子任务的执行。</li><li> 由于线程是被调度的基本单元，而进程不是调度单元。所以，每个进程在创建时，至少需要同时为该进程创建一个线程。即进程中至少要有一个或一个以上的线程，否则该进程无法被调度执行。</li><li> 进程是被分给并拥有资源的基本单元。同一进程内的多个线程共享该进程的资源，但线程并不拥有资源，只是使用他们。</li><li> 线程是操作系统中基本调度单元，因此线程中应包含有调度所需要的必要信息，且在生命周期中有状态的变化。</li><li> 由于共享资源【包括数据和文件】，所以线程间需要通信和同步机制，且需要时线程可以创建其他线程，但线程间不存在父子关系。</li></ol><h3 id="多线程使用的情形"><a href="#多线程使用的情形" class="headerlink" title="多线程使用的情形"></a>多线程使用的情形</h3><ul><li>前台和后台工作情况</li><li>异步处理工作情况</li><li>需要加快执行速度情况</li><li>组织复杂工作的情况</li><li>同时有多个用户服务请求的情况等。</li></ul><h3 id="线程机制的优点："><a href="#线程机制的优点：" class="headerlink" title="线程机制的优点："></a>线程机制的优点：</h3><p>多线程运行在同一个进程的相同的地址空间内，和采用多进程相比有以下优点：</p><ol><li> 创建和撤销线程的开销较之进程要少。创建线程时只需要建立线程控制表相应的表目，或有关队列，而创建进程时，要创建PCB表和初始化，进入有关进程队列，建立它的地址空间和所需资源等。</li><li> CPU在线程之间开关时的开销远比进程要少得多。因开关线程都在同一地址空间内，只需要修改线程控制表或队列，不涉及地址空间和其他工作。</li><li> 线程机制也增加了通讯的有效性。进程间的通讯往往要求内核的参与，以提供通讯机制和保护机制，而线程间的通讯是在同一进程的地址空间内，共享主存和文件，无需内核参与。</li></ol><h3 id="进程和线程的区别"><a href="#进程和线程的区别" class="headerlink" title="进程和线程的区别"></a>进程和线程的区别</h3><h4 id="调度"><a href="#调度" class="headerlink" title="调度"></a>调度</h4><p>在传统的操作系统中，CPU调度和分派的基本单位是进程。而在引入线程的操作系统中，则把线程作为CPU调度和分派的基本单位，进程则作为资源拥有的基本单位，从而使传统进程的两个属性分开，线程编程轻装运行，这样可以显著地提高系统的并发性。同一进程中线程的切换不会引起进程切换，从而避免了昂贵的系统调用，但是在由一个进程中的线程切换到另一进程中的线程，依然会引起进程切换。</p><h4 id="并发性"><a href="#并发性" class="headerlink" title="并发性"></a>并发性</h4><p>在引入线程的操作系统中，不仅进程之间可以并发执行，而且在一个进程中的多个线程之间也可以并发执行，因而使操作系统具有更好的并发性，从而更有效地提高系统资源和系统的吞吐量。例如，在一个为引入线程的单CPU操作系统中，若仅设置一个文件服务进程，当它由于某种原因被封锁时，便没有其他的文件服务进程来提供服务。在引入线程的操作系统中，可以在一个文件服务进程设置多个服务线程。当第一个线程等待时，文件服务进程中的第二个线程可以继续运行；当第二个线程封锁时，第三个线程可以继续执行，从而显著地提高了文件服务的质量以及系统的吞吐量。</p><h4 id="拥有资源"><a href="#拥有资源" class="headerlink" title="拥有资源"></a>拥有资源</h4><p>不论是引入了线程的操作系统，还是传统的操作系统，进程都是拥有系统资源的一个独立单位，他可以拥有自己的资源。一般地说，线程自己不能拥有资源（也有一点必不可少的资源），但它可以访问其隶属进程的资源，亦即一个进程的代码段、数据段以及系统资源（如已打开的文件、I/O设备等），可供同一个进程的其他所有线程共享。</p><h4 id="独立性"><a href="#独立性" class="headerlink" title="独立性"></a>独立性</h4><p>在同一进程中的不同线程之间的独立性要比不同进程之间的独立性低得多。这是为了防止进程之间彼此干扰和破坏，每个进程都拥有一个独立的地址空间和其它资源，除了共享全局变量外，不允许其它进程的访问。但是同一进程中的不同线程往往是为了提高并发性以及进行相互之间的合作而创建的，它们共享进程的内存地址空间和资源，如每个线程都可以访问它们所属进程地址空间中的所有地址，如一个线程的堆栈可以被其它线程读、写，甚至完全清除。</p><h4 id="系统开销"><a href="#系统开销" class="headerlink" title="系统开销"></a>系统开销</h4><p>由于在创建或撤销进程时，系统都要为之分配或回收资源，如内存空间、I/O设备等。因此，操作系统为此所付出的开销将显著地大于在创建或撤消线程时的开销。类似的，在进程切换时，涉及到整个当前进程CPU环境的保存环境的设置以及新被调度运行的CPU环境的设置，而线程切换只需保存和设置少量的寄存器的内容，并不涉及存储器管理方面的操作，可见，进程切换的开销也远大于线程切换的开销。此外，由于同一进程中的多个线程具有相同的地址空间，致使他们之间的同步和通信的实现也变得比较容易。在有的系统中，现成的切换、同步、和通信都无需操作系统内核的干预。</p><h4 id="支持多处理机系统"><a href="#支持多处理机系统" class="headerlink" title="支持多处理机系统"></a>支持多处理机系统</h4><p>在多处理机系统中，对于传统的进程，即单线程进程，不管有多少处理机，该进程只能运行在一个处理机上。但对于多线程进程，就可以将一个进程中的多个线程分配到多个处理机上，使它们并行执行，这无疑将加速进程的完成。因此，现代处理机OS都无一例外地引入了多线程。</p>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
          <category> 计算机基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 进程 </tag>
            
            <tag> 线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Consul使用笔记</title>
      <link href="2021/06/18/consul-xue-xi-bi-ji/"/>
      <url>2021/06/18/consul-xue-xi-bi-ji/</url>
      
        <content type="html"><![CDATA[<h2 id="使用Consul"><a href="#使用Consul" class="headerlink" title="使用Consul"></a>使用Consul</h2><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>Consul包含多个组件,但是作为一个整体,为你的基础设施提供服务发现和服务配置的工具.他提供以下关键特性:</p><p>服务发现 Consul的客户端可用提供一个服务,比如 api 或者mysql ,另外一些客户端可用使用Consul去发现一个指定服务的提供者.通过DNS或者HTTP应用程序可用很容易的找到他所依赖的服务.<br>健康检查 Consul客户端可用提供任意数量的健康检查,指定一个服务(比如:webserver是否返回了200 OK 状态码)或者使用本地节点(比如:内存使用是否大于90%). 这个信息可由operator用来监视集群的健康.被服务发现组件用来避免将流量发送到不健康的主机.<br>Key/Value存储 应用程序可用根据自己的需要使用Consul的层级的Key/Value存储.比如动态配置,功能标记,协调,领袖选举等等,简单的HTTP API让他更易于使用.<br>多数据中心: Consul支持开箱即用的多数据中心.这意味着用户不需要担心需要建立额外的抽象层让业务扩展到多个区域.<br>Consul面向DevOps和应用开发者友好.是他适合现代的弹性的基础设施.</p><p><img src="../images/consul-cluster.png" alt="consul-cluster"></p><h3 id="基础架构"><a href="#基础架构" class="headerlink" title="基础架构"></a>基础架构</h3><p>Consul是一个分布式高可用的系统. 这节将包含一些基础,我们忽略掉一些细节这样你可以快速了解Consul是如何工作的.如果要了解更多细节,请参考深入的架构描述.</p><p>每个提供服务给Consul的阶段都运行了一个Consul agent . 发现服务或者设置和获取 key/value存储的数据不是必须运行agent.这个agent是负责对节点自身和节点上的服务进行健康检查的.</p><p>Agent与一个和多个Consul Server 进行交互.Consul Server 用于存放和复制数据.server自行选举一个领袖.虽然Consul可以运行在一台server , 但是建议使用3到5台来避免失败情况下数据的丢失.每个数据中心建议配置一个server集群.</p><p>你基础设施中需要发现其他服务的组件可以查询任何一个Consul 的server或者 agent.Agent会自动转发请求到server .</p><p>每个数据中运行了一个Consul server集群.当一个跨数据中心的服务发现和配置请求创建时.本地Consul Server转发请求到远程的数据中心并返回结果.</p><p>更多介绍查看官网<a href="https://www.consul.io/">点击前往</a></p><h3 id="安装Consul"><a href="#安装Consul" class="headerlink" title="安装Consul"></a>安装Consul</h3><p>安装Consul,找到适合你系统的包下载他.Consul打包为一个’Zip’文件.<a href="https://www.consul.io/downloads.html">前往下载</a></p><p>下载后解开压缩包.拷贝Consul到你的PATH路径中,在Unix系统中<code>~/bin</code>和<code>/usr/local/bin</code>是通常的安装目录.根据你是想为单个用户安装还是给整个系统安装来选择.在Windows系统中有可以安装到%PATH%的路径中.</p><h3 id="验证安装"><a href="#验证安装" class="headerlink" title="验证安装"></a>验证安装</h3><p>完成安装后,通过打开一个新终端窗口检查<code>consul</code>安装是否成功.通过执行 <code>consul</code>,你应该看到类似下面的输出</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">[root@dhcp-10-201-102-248 ~]# consulusage: consul [--version] [--help] &lt;command&gt; [&lt;args&gt;]Available commands are:    agent          Runs a Consul agent    configtest     Validate config file    event          Fire a new event    exec           Executes a command on Consul nodes    force-leave    Forces a member of the cluster to enter the "left" state    info           Provides debugging information for operators    join           Tell Consul agent to join cluster    keygen         Generates a new encryption key    keyring        Manages gossip layer encryption keys    kv             Interact with the key-value store    leave          Gracefully leaves the Consul cluster and shuts down    lock           Execute a command holding a lock    maint          Controls node or service maintenance mode    members        Lists the members of a Consul cluster    monitor        Stream logs from a Consul agent    operator       Provides cluster-level tools for Consul operators    reload         Triggers the agent to reload configuration files    rtt            Estimates network round trip time between nodes    snapshot       Saves, restores and inspects snapshots of Consul server state    version        Prints the Consul version    watch          Watch for changes in Consul<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果你得到一个<code>consul not be found</code>的错误,你的<code>PATH</code>可能没有正确设置.请返回检查你的<code>consul</code>的安装路径是否包含在<code>PATH</code>中.</p><h3 id="运行Agent"><a href="#运行Agent" class="headerlink" title="运行Agent"></a>运行Agent</h3><p>完成Consul的安装后,必须运行agent. agent可以运行为<code>server</code>或<code>client</code>模式.每个数据中心至少必须拥有一台server . 建议在一个集群中有3或者5个server.部署单一的server,在出现失败时会不可避免的造成数据丢失.</p><p>其他的agent运行为client模式.一个client是一个非常轻量级的进程.用于注册服务,运行健康检查和转发对server的查询.agent必须在集群中的每个主机上运行.</p><p>查看启动数据中心的细节请查看<a href="https://www.consul.io/docs/guides/bootstrapping.html">这里</a>.</p><h3 id="启动-Consul-Server"><a href="#启动-Consul-Server" class="headerlink" title="启动 Consul Server"></a>启动 Consul Server</h3><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">consul agent -server -bootstrap-expect 3 -data-dir /tmp/consul -node=s1 -bind=10.201.102.198 -ui-dir ./consul_ui/ -rejoin -config-dir=/etc/consul.d/ -client 0.0.0.0<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>以<code>server</code>模式,运行cosnul agent</p><ul><li><code>-server</code>: 定义agent运行在server模式</li><li><code>-bootstrap-expect</code>: 在一个datacenter中期望提供的server节点数目, 当该值提供的时候, consul一直等到达到指定sever数目的时候才会引导整个集群, 该标记不能和bootstrap共用</li><li><code>-bind</code>: 该地址用来在集群内部的通讯, 集群内的所有节点到地址都必须是可达的, 默认是0.0.0.0</li><li><code>-node</code>: 节点在集群中的名称, 在一个集群中必须是唯一的, 默认是该节点的主机名</li><li><code>-ui-dir</code>: 提供存放web ui资源的路径, 该目录必须是可读的</li><li><code>-rejoin</code>: 使consul忽略先前的离开, 在再次启动后仍旧尝试加入集群中. </li><li><code>-config-dir</code>: 配置文件目录, 里面所有以.json结尾的文件都会被加载</li><li><code>-client</code>: consul服务侦听地址, 这个地址提供HTTP、DNS、RPC等服务, 默认是127.0.0.1所以不对外提供服务, 如果你要对外提供服务改成0.0.0.0<pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">[root@dhcp-10-201-102-198 consul]# consul agent -server -bootstrap-expect 1 -data-dir /tmp/consul -node=s1 -bind=10.201.102.198 -ui-dir ./consul_ui/ -rejoin -config-dir=/etc/consul.d/ -client 0.0.0.0==&gt; WARNING: Expect Mode enabled, expecting 3 servers==&gt; Starting Consul agent...==&gt; Starting Consul agent RPC...==&gt; Consul agent running!           Version: 'v0.7.4'           Node ID: '422ec677-74ef-8f29-2f22-01effeed6334'         Node name: 's1'        Datacenter: 'dc1'            Server: true (bootstrap: false)       Client Addr: 0.0.0.0 (HTTP: 8500, HTTPS: -1, DNS: 8600, RPC: 8400)      Cluster Addr: 10.201.102.198 (LAN: 8301, WAN: 8302)    Gossip encrypt: false, RPC-TLS: false, TLS-Incoming: false             Atlas: &lt;disabled&gt;==&gt; Log data will now stream in as it occurs:    2017/03/17 18:03:08 [INFO] raft: Restored from snapshot 139-352267-1489707086023    2017/03/17 18:03:08 [INFO] raft: Initial configuration (index=6982): [{Suffrage:Voter ID:10.201.102.199:8300 Address:10.201.102.199:8300} {Suffrage:Voter ID:10.201.102.200:8300 Address:10.201.102.200:8300} {Suffrage:Voter ID:10.201.102.198:8300 Address:10.201.102.198:8300}]    2017/03/17 18:03:08 [INFO] raft: Node at 10.201.102.198:8300 [Follower] entering Follower state (Leader: "")    2017/03/17 18:03:08 [INFO] serf: EventMemberJoin: s1 10.201.102.198    2017/03/17 18:03:08 [INFO] serf: Attempting re-join to previously known node: s2: 10.201.102.199:8301    2017/03/17 18:03:08 [INFO] consul: Adding LAN server s1 (Addr: tcp/10.201.102.198:8300) (DC: dc1)    2017/03/17 18:03:08 [INFO] consul: Raft data found, disabling bootstrap mode    2017/03/17 18:03:08 [INFO] serf: EventMemberJoin: s2 10.201.102.199    2017/03/17 18:03:08 [INFO] serf: EventMemberJoin: s3 10.201.102.200    2017/03/17 18:03:08 [INFO] serf: Re-joined to previously known node: s2: 10.201.102.199:8301    2017/03/17 18:03:08 [INFO] consul: Adding LAN server s2 (Addr: tcp/10.201.102.199:8300) (DC: dc1)    2017/03/17 18:03:08 [INFO] consul: Adding LAN server s3 (Addr: tcp/10.201.102.200:8300) (DC: dc1)    2017/03/17 18:03:08 [INFO] serf: EventMemberJoin: s1.dc1 10.201.102.198    2017/03/17 18:03:08 [INFO] consul: Adding WAN server s1.dc1 (Addr: tcp/10.201.102.198:8300) (DC: dc1)    2017/03/17 18:03:08 [WARN] serf: Failed to re-join any previously known node    2017/03/17 18:03:14 [INFO] agent: Synced service 'consul'    2017/03/17 18:03:14 [INFO] agent: Deregistered service 'consul01'    2017/03/17 18:03:14 [INFO] agent: Deregistered service 'consul02'    2017/03/17 18:03:14 [INFO] agent: Deregistered service 'consul03'<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h4 id="查看集群成员"><a href="#查看集群成员" class="headerlink" title="查看集群成员"></a>查看集群成员</h4><p>新开一个终端窗口运行<code>consul members</code>, 你可以看到Consul集群的成员.</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">[root@dhcp-10-201-102-198 ~]# consul membersNode  Address              Status  Type    Build  Protocol  DCs1    10.201.102.198:8301  alive   server  0.7.4  2         dc1s2    10.201.102.199:8301  alive   server  0.7.4  2         dc1s3    10.201.102.200:8301  alive   server  0.7.4  2         dc1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="启动-Consul-Client"><a href="#启动-Consul-Client" class="headerlink" title="启动 Consul Client"></a>启动 Consul Client</h3><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">consul agent -data-dir /tmp/consul -node=c1 -bind=10.201.102.248 -config-dir=/etc/consul.d/ -join 10.201.102.198<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>运行cosnul agent以client模式, <code>-join</code> 加入到已有的集群中去. </p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">[root@dhcp-10-201-102-248 ~]# consul agent -data-dir /tmp/consul -node=c1 -bind=10.201.102.248 -config-dir=/etc/consul.d/ -join 10.201.102.198==&gt; Starting Consul agent...==&gt; Starting Consul agent RPC...==&gt; Joining cluster...    Join completed. Synced with 1 initial agents==&gt; Consul agent running!           Version: 'v0.7.4'           Node ID: '564dc0c7-7f4f-7402-a301-cebe7f024294'         Node name: 'c1'        Datacenter: 'dc1'            Server: false (bootstrap: false)       Client Addr: 127.0.0.1 (HTTP: 8500, HTTPS: -1, DNS: 8600, RPC: 8400)      Cluster Addr: 10.201.102.248 (LAN: 8301, WAN: 8302)    Gossip encrypt: false, RPC-TLS: false, TLS-Incoming: false             Atlas: &lt;disabled&gt;==&gt; Log data will now stream in as it occurs:    2017/03/17 15:35:16 [INFO] serf: EventMemberJoin: c1 10.201.102.248    2017/03/17 15:35:16 [INFO] agent: (LAN) joining: [10.201.102.198]    2017/03/17 15:35:16 [INFO] serf: EventMemberJoin: s2 10.201.102.199    2017/03/17 15:35:16 [INFO] serf: EventMemberJoin: s3 10.201.102.200    2017/03/17 15:35:16 [INFO] serf: EventMemberJoin: s1 10.201.102.198    2017/03/17 15:35:16 [INFO] agent: (LAN) joined: 1 Err: &lt;nil&gt;    2017/03/17 15:35:16 [INFO] consul: adding server s2 (Addr: tcp/10.201.102.199:8300) (DC: dc1)    2017/03/17 15:35:16 [INFO] consul: adding server s3 (Addr: tcp/10.201.102.200:8300) (DC: dc1)    2017/03/17 15:35:16 [INFO] consul: adding server s1 (Addr: tcp/10.201.102.198:8300) (DC: dc1)    2017/03/17 15:35:16 [INFO] agent: Synced node info<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="查看集群成员-1"><a href="#查看集群成员-1" class="headerlink" title="查看集群成员"></a>查看集群成员</h4><p>新开一个终端窗口运行<code>consul members</code>, 你可以看到Consul集群的成员.</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">[root@dhcp-10-201-102-248 ~]# consul membersNode  Address              Status  Type    Build  Protocol  DCc1    10.201.102.248:8301  alive   client  0.7.4  2         dc1s1    10.201.102.198:8301  alive   server  0.7.4  2         dc1s2    10.201.102.199:8301  alive   server  0.7.4  2         dc1s3    10.201.102.200:8301  alive   server  0.7.4  2         dc1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="加入集群"><a href="#加入集群" class="headerlink" title="加入集群"></a>加入集群</h4><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">[root@dhcp-10-201-102-248 ~]# consul join 10.201.102.198Node  Address              Status  Type    Build  Protocol  DCc1    10.201.102.248:8301  alive   client  0.7.4  2         dc1s1    10.201.102.198:8301  alive   server  0.7.4  2         dc1s2    10.201.102.199:8301  alive   server  0.7.4  2         dc1s3    10.201.102.200:8301  alive   server  0.7.4  2         dc1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="停止Agent"><a href="#停止Agent" class="headerlink" title="停止Agent"></a>停止Agent</h3><p>你可以使用<code>Ctrl-C</code> 优雅的关闭Agent. 中断Agent之后你可以看到他离开了集群并关闭.</p><p>在退出中,Consul提醒其他集群成员,这个节点离开了.如果你强行杀掉进程.集群的其他成员应该能检测到这个节点失效了.当一个成员离开,他的服务和检测也会从目录中移除.当一个成员失效了,他的健康状况被简单的标记为危险,但是不会从目录中移除.Consul会自动尝试对失效的节点进行重连.允许他从某些网络条件下恢复过来.离开的节点则不会再继续联系.</p><p>此外,如果一个agent作为一个服务器,一个优雅地离开是很重要的,可以避免引起潜在的可用性故障影响达成<a href="https://www.consul.io/docs/internals/consensus.html">一致性协议</a>.</p><p>查看<a href="https://www.consul.io/docs/internals/consensus.html">这里</a>了解添加和移除server.</p><h3 id="更新服务"><a href="#更新服务" class="headerlink" title="更新服务"></a>更新服务</h3><p>服务定义可以通过配置文件并发送<code>SIGHUP</code>给agent来进行更新.这样你可以让你在不关闭服务或者保持服务请求可用的情况下进行更新.</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">consul reload<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>另外 HTTP API可以用来动态的添加,移除和修改服务.</p><h3 id="注册服务"><a href="#注册服务" class="headerlink" title="注册服务"></a>注册服务</h3><p>搭建好conusl集群后, 用户或者程序就能到consul中去查询或者注册服务. 可以通过提供服务定义文件或者调用HTTP API来注册一个服务.</p><p>首先,为Consul配置创建一个目录.Consul会载入配置文件夹里的所有配置文件.在Unix系统中通常类似 <code>/etc/consul.d</code> (.d 后缀意思是这个路径包含了一组配置文件).</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">mkdir /etc/consul.d<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>然后,我们将编写服务定义配置文件.假设我们有一个名叫<code>web</code>的服务运行在 80端口.另外,我们将给他设置一个标签.这样我们可以使用他作为额外的查询方式:</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">echo '{"service": {"name": "web", "tags": ["rails"], "port": 80}}' &gt;/etc/consul.d/web.json<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>现在重启agent , 设置配置目录:</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">$ consul agent -server -bootstrap-expect 1 -data-dir /tmp/consul -node=s1 -bind=10.201.102.198 -rejoin -config-dir=/etc/consul.d/ -client 0.0.0.0...    [INFO] agent: Synced service 'web'...<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><code>-data-dir</code>: 提供一个目录用来存放agent的状态, 所有的agent允许都需要该目录, 该目录必须是稳定的, 系统重启后都继续存在<br>你可能注意到了输出了 “synced” 了 web这个服务.意思是这个agent从配置文件中载入了服务定义,并且成功注册到服务目录.</li></ul><p>如果你想注册多个服务,你应该在Consul配置目录创建多个服务定义文件.</p><p>HTTP API注册服务,curl命令或者postman 以<code>PUT</code>方式请求consul HTTP API更多细节<a href="https://www.consul.io/docs/agent/http/catalog.html#catalog_register">点击查看</a></p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">curl -X PUT -d '{"Datacenter": "dc1", "Node": "c2", "Address": "10.155.0.106", "Service": {"Service": "MAC", "tags": ["lianglian", "Mac"], "Port": 22}}' http://127.0.0.1:8500/v1/catalog/register<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="查询服务"><a href="#查询服务" class="headerlink" title="查询服务"></a>查询服务</h3><p>一旦agent启动并且服务同步了.我们可以通过DNS或者HTTP的API来查询服务.</p><h4 id="DNS-API"><a href="#DNS-API" class="headerlink" title="DNS API"></a>DNS API</h4><p>让我们首先使用DNS API来查询.在DNS API中,服务的DNS名字是 <code>NAME.service.consul</code>. 虽然是可配置的,但默认的所有DNS名字会都在<code>consul</code>命名空间下.这个子域告诉Consul,我们在查询服务,<code>NAME</code>则是服务的名称.</p><p>对于我们上面注册的Web服务.它的域名是 <code>web.service.consul</code> :</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">[root@dhcp-10-201-102-198 ~]# dig @127.0.0.1 -p 8600 web.service.consul; &lt;&lt;&gt;&gt; DiG 9.8.2rc1-RedHat-9.8.2-0.17.rc1.el6 &lt;&lt;&gt;&gt; @127.0.0.1 -p 8600 web.service.consul; (1 server found);; global options: +cmd;; Got answer:;; -&gt;&gt;HEADER&lt;&lt;- opcode: QUERY, status: NOERROR, id: 39468;; flags: qr aa rd; QUERY: 1, ANSWER: 1, AUTHORITY: 0, ADDITIONAL: 0;; WARNING: recursion requested but not available;; QUESTION SECTION:;web.service.consul.            IN      A;; ANSWER SECTION:web.service.consul.     0       IN      A       10.201.102.198;; Query time: 0 msec;; SERVER: 127.0.0.1#8600(127.0.0.1);; WHEN: Tue Mar 28 16:10:24 2017;; MSG SIZE  rcvd: 52<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如你所见,一个<code>A</code>记录返回了一个可用的服务所在的节点的IP地址.A`记录只能设置为IP地址. 有也可用使用 DNS API 来接收包含 地址和端口的 SRV记录:</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">[root@dhcp-10-201-102-198 ~]# dig @127.0.0.1 -p 8600 web.service.consul SRV; &lt;&lt;&gt;&gt; DiG 9.8.2rc1-RedHat-9.8.2-0.17.rc1.el6 &lt;&lt;&gt;&gt; @127.0.0.1 -p 8600 web.service.consul SRV; (1 server found);; global options: +cmd;; Got answer:;; -&gt;&gt;HEADER&lt;&lt;- opcode: QUERY, status: NOERROR, id: 13331;; flags: qr aa rd; QUERY: 1, ANSWER: 1, AUTHORITY: 0, ADDITIONAL: 1;; WARNING: recursion requested but not available;; QUESTION SECTION:;web.service.consul.            IN      SRV;; ANSWER SECTION:web.service.consul.     0       IN      SRV     1 1 80 s1.node.dc1.consul.;; ADDITIONAL SECTION:s1.node.dc1.consul.     0       IN      A       10.201.102.198;; Query time: 0 msec;; SERVER: 127.0.0.1#8600(127.0.0.1);; WHEN: Tue Mar 28 16:10:56 2017;; MSG SIZE  rcvd: 84<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>SRV</code>记录告诉我们 <code>web</code> 这个服务运行于节点<code>dhcp-10-201-102-198</code> 的<code>80</code>端口. DNS额外返回了节点的A记录.</p><p>最后,我们也可以用 DNS API 通过标签来过滤服务.基于标签的服务查询格式为<code>TAG.NAME.service.consul</code>. 在下面的例子中,我们请求Consul返回有 <code>rails</code>标签的 <code>web</code>服务.我们成功获取了我们注册为这个标签的服务:</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">[root@dhcp-10-201-102-198 ~]# dig @127.0.0.1 -p 8600 rails.web.service.consul SRV; &lt;&lt;&gt;&gt; DiG 9.8.2rc1-RedHat-9.8.2-0.17.rc1.el6 &lt;&lt;&gt;&gt; @127.0.0.1 -p 8600 rails.web.service.consul SRV; (1 server found);; global options: +cmd;; Got answer:;; -&gt;&gt;HEADER&lt;&lt;- opcode: QUERY, status: NOERROR, id: 37307;; flags: qr aa rd; QUERY: 1, ANSWER: 1, AUTHORITY: 0, ADDITIONAL: 1;; WARNING: recursion requested but not available;; QUESTION SECTION:;rails.web.service.consul.      IN      SRV;; ANSWER SECTION:rails.web.service.consul. 0     IN      SRV     1 1 80 s1.node.dc1.consul.;; ADDITIONAL SECTION:s1.node.dc1.consul.     0       IN      A       10.201.102.198;; Query time: 0 msec;; SERVER: 127.0.0.1#8600(127.0.0.1);; WHEN: Tue Mar 28 16:11:45 2017;; MSG SIZE  rcvd: 90<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="HTTP-API"><a href="#HTTP-API" class="headerlink" title="HTTP API"></a>HTTP API</h4><p>除了DNS API之外,HTTP API也可以用来进行服务查询:</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">[root@dhcp-10-201-102-198 ~]# curl -s 127.0.0.1:8500/v1/catalog/service/web | python -m json.tool[    {        "Address": "10.201.102.198",        "CreateIndex": 492843,        "ID": "422ec677-74ef-8f29-2f22-01effeed6334",        "ModifyIndex": 492843,        "Node": "s1",        "NodeMeta": {},        "ServiceAddress": "",        "ServiceEnableTagOverride": false,        "ServiceID": "web",        "ServiceName": "web",        "ServicePort": 80,        "ServiceTags": [            "rails"        ],        "TaggedAddresses": {            "lan": "10.201.102.198",            "wan": "10.201.102.198"        }    }]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>目录API给出所有节点提供的服务.稍后我们会像通常的那样带上健康检查进行查询.就像DNS内部处理的那样.这是只查看健康的实例的查询方法:</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">[root@dhcp-10-201-102-198 ~]# curl -s 127.0.0.1:8500/v1/catalog/service/web?passing | python -m json.tool[    {        "Address": "10.201.102.198",        "CreateIndex": 492843,        "ID": "422ec677-74ef-8f29-2f22-01effeed6334",        "ModifyIndex": 492843,        "Node": "s1",        "NodeMeta": {},        "ServiceAddress": "",        "ServiceEnableTagOverride": false,        "ServiceID": "web",        "ServiceName": "web",        "ServicePort": 80,        "ServiceTags": [            "rails"        ],        "TaggedAddresses": {            "lan": "10.201.102.198",            "wan": "10.201.102.198"        }    }]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="WEB管理界面"><a href="#WEB管理界面" class="headerlink" title="WEB管理界面"></a>WEB管理界面</h3><p>Consul同时提供了一个漂亮的功能齐全的WEB界面,开箱即用.界面可以用来查看所有的节点,可以查看健康检查和他们的当前状态.可以读取和设置K/V 存储的数据.UI自动支持多数据中心.<a href="https://www.consul.io/downloads.html">点击前往下载</a><br><img src="../images/UI_Download.png" alt="UI_Download"></p><p>下载完后上传至服务器, 建议所有server角色都使用WebUI.</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">consul agent -server -bootstrap-expect 1 -data-dir /tmp/consul -node=s1 -bind=10.201.102.198 -ui-dir ./consul_ui/ -rejoin -config-dir=/etc/consul.d/ -client 0.0.0.0<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li><code>-ui-dir</code>: 提供存放web ui资源的路径, 指向该目录必须是可读的</li><li><code>-client</code>: consul服务侦听地址, 这个地址提供HTTP、DNS、RPC等服务, 默认是127.0.0.1所以不对外提供服务, 如果你要对外提供服务改成0.0.0.0<br>可通过<a href="http://10.201.102.198:8500/">http://10.201.102.198:8500</a> 访问WEB管理界面.<br><img src="../images/UI_Web.png" alt="UI_Web"></li></ul><h3 id="健康检查"><a href="#健康检查" class="headerlink" title="健康检查"></a>健康检查</h3><p>我们现在看到Consul运行时如此简单.添加节点和服务,查询节点和服务.在这一节.我们将继续添加健康检查到节点和服务.健康检查是服务发现的关键组件.预防使用到不健康的服务.</p><p>这一步建立在前一节的Consul集群创建之上.目前你应该有一个包含多个节点的Consul集群.</p><h4 id="自定义检查"><a href="#自定义检查" class="headerlink" title="自定义检查"></a>自定义检查</h4><p>和服务注册类似,一个检查可以通过检查定义或HTTP API请求来注册.</p><p>我们将使用和检查定义来注册检查.和服务类似,因为这是建立检查最常用的方式.</p><p>在第二个节点的配置目录建立定义文件:</p><p><code>/etc/consul.d/web.json</code></p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">{"service": {    "name": "Faceid",    "tags": ["extract", "verify", "compare", "idcard"],    "address": "10.201.102.198",    "port": 9000,    "check": {        "name": "ping",        "script": "curl -s localhost:9000",        "interval": "3s"        }    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>or</p><p><code>/etc/consul.d/web.json</code></p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">{"service": {    "name": "Faceid",    "tags": ["extract", "verify", "compare", "idcard"],    "address": "10.201.102.199",    "port": 9000,    "check": {        "id": "api",           "name": "HTTP API on port 9000",        "http": "http://localhost:9000",        "interval": "10s",        "timeout": "1s"        }   }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><a href="https://www.consul.io/docs/agent/checks.html">more</a></p><h3 id="检查健康状态"><a href="#检查健康状态" class="headerlink" title="检查健康状态"></a>检查健康状态</h3><p>我们能适应HTTP API来检查他们.首先我们检查有哪些失败的检查.使用这个命令(注意:这个命令可以运行在任何节点)</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">[root@dhcp-10-201-102-198 ~]# curl -s http://localhost:8500/v1/health/state/critical | python -m json.tool[    {        "CheckID": "service:Faceid",        "CreateIndex": 493398,        "ModifyIndex": 493846,        "Name": "Service 'Faceid' check",        "Node": "s1",        "Notes": "",        "Output": "",        "ServiceID": "Faceid",        "ServiceName": "Faceid",        "Status": "critical"    }]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们可以看到,只有一个检查我们的<code>web</code>服务在<code>critical</code>状态</p><p>另外,我们可以尝试用DNS查询web服务,Consul将不会返回结果.因为服务不健康.</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">[root@dhcp-10-201-102-198 ~]# dig @127.0.0.1 -p 8600 Faceid.service.consul SRV; &lt;&lt;&gt;&gt; DiG 9.8.2rc1-RedHat-9.8.2-0.17.rc1.el6 &lt;&lt;&gt;&gt; @127.0.0.1 -p 8600 Faceid.service.consul SRV; (1 server found);; global options: +cmd;; Got answer:;; -&gt;&gt;HEADER&lt;&lt;- opcode: QUERY, status: NOERROR, id: 40884;; flags: qr aa rd; QUERY: 1, ANSWER: 3, AUTHORITY: 0, ADDITIONAL: 3;; WARNING: recursion requested but not available;; QUESTION SECTION:;Faceid.service.consul.         IN      SRV;; ANSWER SECTION:Faceid.service.consul.  0       IN      SRV     1 1 9000 s3.node.dc1.consul.Faceid.service.consul.  0       IN      SRV     1 1 9000 s1.node.dc1.consul.Faceid.service.consul.  0       IN      SRV     1 1 9000 s2.node.dc1.consul.;; ADDITIONAL SECTION:s3.node.dc1.consul.     0       IN      A       10.201.102.200s1.node.dc1.consul.     0       IN      A       10.201.102.198s2.node.dc1.consul.     0       IN      A       10.201.102.199;; Query time: 0 msec;; SERVER: 127.0.0.1#8600(127.0.0.1);; WHEN: Tue Mar 28 18:20:15 2017;; MSG SIZE  rcvd: 165<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="K-V"><a href="#K-V" class="headerlink" title="K/V"></a>K/V</h3><p>除了提供服务发现和健康检查的集成.Consul提供了一个易用的键/值存储.这可以用来保持动态配置,协助服务协调,领袖选举,做开发者可以想到的任何事情.</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">[root@dhcp-10-201-102-198 ~]# curl -v http://localhost:8500/v1/kv/?recurse* About to connect() to localhost port 8500 (#0)*   Trying ::1... 拒绝连接*   Trying 127.0.0.1... connected* Connected to localhost (127.0.0.1) port 8500 (#0)&gt; GET /v1/kv/?recurse HTTP/1.1&gt; User-Agent: curl/7.19.7 (x86_64-redhat-linux-gnu) libcurl/7.19.7 NSS/3.21 Basic ECC zlib/1.2.3 libidn/1.18 libssh2/1.4.2&gt; Host: localhost:8500&gt; Accept: */*&gt;&lt; HTTP/1.1 404 Not Found&lt; X-Consul-Index: 1&lt; X-Consul-Knownleader: true&lt; X-Consul-Lastcontact: 0&lt; Date: Thu, 18 Aug 2016 08:21:39 GMT&lt; Content-Length: 0&lt; Content-Type: text/plain; charset=utf-8&lt;* Connection #0 to host localhost left intact* Closing connection #0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>因为没有key所以我们得到了一个404响应.现在我们PUT`一些示例的Key:</p><pre class="line-numbers language-none"><code class="language-none">[root@dhcp-10-201-102-198 ~]# curl -X PUT -d 'test' http://localhost:8500/v1/kv/web/key1[root@dhcp-10-201-102-198 ~]# curl -X PUT -d 'test' http://localhost:8500/v1/kv/web/key2?flags=42[root@dhcp-10-201-102-198 ~]# curl -X PUT -d 'test'  http://localhost:8500/v1/kv/web/sub/key3<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>我们创建了值为”test”的3个Key,注意返回的值是经过了base64编码的.用来支持非UTF8编码字符.对Key <code>web/key2</code>我们设置了一个标志值为 <code>42</code>.所有的key支持设置一个64位的整形数字标志.Consul内部不适用这个值.但是他可以被客户端适用来做一些元数据.</p><p>完成设置后,我们发起了一个<code>GET</code>请求来接收多个key的值,使用<code>?recurse</code>参数.</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">[root@dhcp-10-201-102-198 ~]# curl -s http://localhost:8500/v1/kv/web/?recurse | python -m json.tool[    {        "CreateIndex": 502660,        "Flags": 0,        "Key": "web/key1",        "LockIndex": 0,        "ModifyIndex": 502660,        "Value": "dGVzdA=="    },    {        "CreateIndex": 502663,        "Flags": 42,        "Key": "web/key2",        "LockIndex": 0,        "ModifyIndex": 502663,        "Value": "dGVzdA=="    },    {        "CreateIndex": 502665,        "Flags": 0,        "Key": "web/sub/key3",        "LockIndex": 0,        "ModifyIndex": 502665,        "Value": "dGVzdA=="    }]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>你可以获取单个的key</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">[root@dhcp-10-201-102-198 ~]# curl -s http://localhost:8500/v1/kv/web/key1 | python -m json.tool[    {        "CreateIndex": 502660,        "Flags": 0,        "Key": "web/key1",        "LockIndex": 0,        "ModifyIndex": 502660,        "Value": "dGVzdA=="    }]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>删除key也很简单.通过<code>DELETE</code>动作来完成.我们可以通过指定完整路径来删除一个单独的key.或者我们可以使用<code>?recurse</code>递归的删除主路径下所有key.</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">[root@dhcp-10-201-102-198 ~]# curl -X DELETE http://localhost:8500/v1/kv/web/sub?recursetrue<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>可以通过发送相同的URL并提供不同的消息体的<code>PUT</code>请求去修改一个Key.另外,Consul提供一个检查并设置的操作,实现原子的Key修改.通过<code>?cas=</code>参数加上<code>GET</code>中最近的<code>ModifyIndex</code>来达到. 例如我们想修改 “web/key1”:</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">curl -X PUT -d 'newval' http://localhost:8500/v1/kv/web/key1?cas=502660truecurl -X PUT -d 'newval' http://localhost:8500/v1/kv/web/key1?cas=502660false<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>在这种情况下,第一次<code>CAS</code> 更新成功因为<code>ModifyIndex</code>是<code>502660</code>.而第二次失败是因为<code>ModifyIndex</code>在第一次更新后已经不是<code>502660</code>了 .</p><p>我们也可以使用<code>ModifyIndex</code>来等待key值的改变.例如我们想等待<code>key2</code>被修改:</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">[root@dhcp-10-201-102-198 ~]# curl "http://localhost:8500/v1/kv/web/key2"[{"LockIndex":0,"Key":"web/key2","Flags":42,"Value":"dGVzdA==","CreateIndex":502663,"ModifyIndex":502663}][root@dhcp-10-201-102-198 ~]# curl "http://localhost:8500/v1/kv/web/key2?index=502663&amp;wait=5s"[{"LockIndex":0,"Key":"web/key2","Flags":42,"Value":"dGVzdA==","CreateIndex":502663,"ModifyIndex":502663}]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>通过提供 <code>?index=</code>,我们请求等待key值有一个比<code>502663</code>更大的<code>ModifyIndex</code>.虽然<code>?wait=5s</code>参数限制了这个请求最多5秒,否则返回当前的未改变的值. 这样可以有效的等待key的改变.另外,这个功能可以用于等待一组key.直到其中的某个key有修改.</p><h2 id="Conusl-命令行"><a href="#Conusl-命令行" class="headerlink" title="Conusl 命令行"></a>Conusl 命令行</h2><p>见识了consul的强大, consul可以通过一个简单的CLI来控制, consul只有一个命令行应用, 就是consul命令, consul命令可以包含agent、members等参数进行使用, 这一篇来具体看看consul CLI的具体用法, consul -h即可看到consul cli所支持的参数, 而每个参数里面又支持其他参数, 下面我们就来具体看看. </p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">[root@dhcp-10-201-102-198 ~]# consulusage: consul [--version] [--help] &lt;command&gt; [&lt;args&gt;]Available commands are:    agent          Runs a Consul agent  运行一个consul agent    configtest     Validate config file    event          Fire a new event    exec           Executes a command on Consul nodes  在consul节点上执行一个命令    force-leave    Forces a member of the cluster to enter the "left" state   强制节点成员在集群中的状态转换到left状态    info           Provides debugging information for operators  提供操作的debug级别的信息    join           Tell Consul agent to join cluster   加入consul节点到集群中    keygen         Generates a new encryption key  生成一个新的加密key    keyring        Manages gossip layer encryption keys    kv             Interact with the key-value store    leave          Gracefully leaves the Consul cluster and shuts down    lock           Execute a command holding a lock    maint          Controls node or service maintenance mode    members        Lists the members of a Consul cluster    列出集群中成员    monitor        Stream logs from a Consul agent  打印consul节点的日志信息    operator       Provides cluster-level tools for Consul operators    reload         Triggers the agent to reload configuration files   触发节点重新加载配置文件    rtt            Estimates network round trip time between nodes    snapshot       Saves, restores and inspects snapshots of Consul server state    version        Prints the Consul version    打印consul的版本信息    watch          Watch for changes in Consul   监控consul的改变<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>更详细见<a href="https://www.consul.io/docs/commands/index.html">官网</a></p><h3 id="Agent"><a href="#Agent" class="headerlink" title="Agent"></a>Agent</h3><p><code>agent</code>指令是consul的核心, 它运行agent来维护成员的重要信息、运行检查、服务宣布、查询处理等等. </p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">==&gt; Usage: consul agent [options]Starts the Consul agent and runs until an interrupt is received. Theagent represents a single node in a cluster.Options:-advertise=addr                  Sets the advertise address to use-advertise-wan=addr              Sets address to advertise on wan instead of                                   advertise addr-bootstrap                       Sets server to bootstrap mode-bind=0.0.0.0                    Sets the bind address for cluster                                   communication-http-port=8500                  Sets the HTTP API port to listen on-bootstrap-expect=0              Sets server to expect bootstrap mode.-client=127.0.0.1                Sets the address to bind for client access.                                   This includes RPC, DNS, HTTP and HTTPS (if                                   configured)-config-file=foo                 Path to a JSON file to read configuration                                   from. This can be specified multiple times.-config-dir=foo                  Path to a directory to read configuration                                   files from. This will read every file ending                                   in ".json" as configuration in this                                   directory in alphabetical order. This can be                                   specified multiple times.-data-dir=path                   Path to a data directory to store agent                                   state-dev                             Starts the agent in development mode.-recursor=1.2.3.4                Address of an upstream DNS server.                                   Can be specified multiple times.-dc=east-aws                     Datacenter of the agent (deprecated: use                                   'datacenter' instead).-datacenter=east-aws             Datacenter of the agent.-encrypt=key                     Provides the gossip encryption key-join=1.2.3.4                    Address of an agent to join at start time.                                   Can be specified multiple times.-join-wan=1.2.3.4                Address of an agent to join -wan at start                                   time. Can be specified multiple times.-retry-join=1.2.3.4              Address of an agent to join at start time                                   with retries enabled. Can be specified                                   multiple times.-retry-interval=30s              Time to wait between join attempts.-retry-max=0                     Maximum number of join attempts. Defaults to                                   0, which will retry indefinitely.-retry-join-ec2-region           EC2 Region to use for discovering servers to                                   join.-retry-join-ec2-tag-key          EC2 tag key to filter on for server                                   discovery-retry-join-ec2-tag-value        EC2 tag value to filter on for server                                   discovery-retry-join-gce-project-name     Google Compute Engine project to discover                                   servers in-retry-join-gce-zone-pattern     Google Compute Engine region or zone to                                   discover servers in (regex pattern)-retry-join-gce-tag-value        Google Compute Engine tag value to filter                                   for server discovery-retry-join-gce-credentials-file Path to credentials JSON file to use with                                   Google Compute Engine-retry-join-wan=1.2.3.4          Address of an agent to join -wan at start                                   time with retries enabled. Can be specified                                   multiple times.-retry-interval-wan=30s          Time to wait between join -wan attempts.-retry-max-wan=0                 Maximum number of join -wan attempts.                                   Defaults to 0, which will retry                                   indefinitely.-log-level=info                  Log level of the agent.-node=hostname                   Name of this node. Must be unique in the                                   cluster-node-meta=key:value             An arbitrary metadata key/value pair for                                   this node.                                   This can be specified multiple times.-protocol=N                      Sets the protocol version. Defaults to                                   latest.-rejoin                          Ignores a previous leave and attempts to                                   rejoin the cluster.-server                          Switches agent to server mode.-syslog                          Enables logging to syslog-ui                              Enables the built-in static web UI server-ui-dir=path                     Path to directory containing the Web UI                                   resources-pid-file=path                   Path to file to store agent PID<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="event"><a href="#event" class="headerlink" title="event"></a>event</h3><p><code>event</code>命令提供了一种机制, 用来fire自定义的用户事件, 这些事件对consul来说是不透明的, 但它们可以用来构建自动部署、重启服务或者其他行动的脚本. </p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">-http-addr: http服务的地址, agent可以链接上来发送命令, 如果没有设置, 则默认是127.0.0.1:8500. -datacenter: 数据中心. -name: 事件的名称-node: 一个正则表达式, 用来过滤节点-service: 一个正则表达式, 用来过滤节点上匹配的服务-tag: 一个正则表达式, 用来过滤节点上符合tag的服务, 必须和-service一起使用. <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="exec"><a href="#exec" class="headerlink" title="exec"></a>exec</h3><p><code>exec</code>指令提供了一种远程执行机制, 比如你要在所有的机器上执行uptime命令, 远程执行的工作通过job来指定, 存储在KV中, agent使用event系统可以快速的知道有新的job产生, 消息是通过gossip协议来传递的, 因此消息传递是最佳的, 但是并不保证命令的执行. 事件通过gossip来驱动, 远程执行依赖KV存储系统(就像消息代理一样). </p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">-http-addr: http服务的地址, agent可以链接上来发送命令, 如果没有设置, 则默认是127.0.0.1:8500. -datacenter: 数据中心. -prefix: key在KV系统中的前缀, 用来存储请求数据, 默认是_rexec-node: 一个正则表达式, 用来过滤节点, 评估事件-service: 一个正则表达式, 用来过滤节点上匹配的服务-tag: 一个正则表达式, 用来过滤节点上符合tag的服务, 必须和-service一起使用. -wait: 在节点多长时间没有响应后, 认为job已经完成. -wait-repl: -verbose: 输出更多信息<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="force-leave"><a href="#force-leave" class="headerlink" title="force-leave"></a>force-leave</h3><p><code>force-leave</code>治疗可以强制consul集群中的成员进入left状态(空闲状态), 记住, 即使一个成员处于活跃状态, 它仍旧可以再次加入集群中, 这个方法的真实目的是强制移除failed的节点. 如果failed的节点还是网络的一部分, 则consul会周期性的重新链接failed的节点, 如果经过一段时间后(默认是72小时), consul则会宣布停止尝试链接failed的节点. force-leave指令可以快速的把failed节点转换到left状态. </p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">-rpc-addr</span><span class="token punctuation">:</span> 一个rpc地址<span class="token punctuation">,</span> agent可以链接上来发送命令<span class="token punctuation">,</span> 如果没有指定<span class="token punctuation">,</span> 默认是127.0.0.1<span class="token punctuation">:</span><span class="token number">8400.</span> <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="info"><a href="#info" class="headerlink" title="info"></a>info</h3><p><code>info</code>指令提供了各种操作时可以用到的debug信息, 对于client和server, info有返回不同的子系统信息, 目前有以下几个KV信息: agent(提供agent信息), consul(提供consul库的信息), raft(提供raft库的信息), serf_lan(提供LAN gossip pool),serf_wan(提供WAN gossip pool)</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">-rpc-addr</span><span class="token punctuation">:</span> 一个rpc地址<span class="token punctuation">,</span> agent可以链接上来发送命令<span class="token punctuation">,</span> 如果没有指定<span class="token punctuation">,</span> 默认是127.0.0.1<span class="token punctuation">:</span><span class="token number">8400</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="join"><a href="#join" class="headerlink" title="join"></a>join</h3><p><code>join</code>指令告诉consul agent加入一个已经存在的集群中, 一个新的consul agent必须加入一个已经有至少一个成员的集群中, 这样它才能加入已经存在的集群中, 如果你不加入一个已经存在的集群, 则agent是它自身集群的一部分, 其他agent则可以加入进来. agents可以加入其他agent多次. consul join [options] address. 如果你想加入多个集群, 则可以写多个地址, consul会加入所有的地址. </p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">-wan</span><span class="token punctuation">:</span> agent运行在server模式<span class="token punctuation">,</span> xxxxxxx<span class="token key atrule">-rpc-addr</span><span class="token punctuation">:</span> 一个rpc地址<span class="token punctuation">,</span> agent可以链接上来发送命令<span class="token punctuation">,</span> 如果没有指定<span class="token punctuation">,</span> 默认是127.0.0.1<span class="token punctuation">:</span><span class="token number">8400.</span> <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="keygen"><a href="#keygen" class="headerlink" title="keygen"></a>keygen</h3><p><code>keygen</code>指令生成加密的密钥, 可以用在consul agent通讯加密</p><ul><li>生成一个key</li></ul><h3 id="leave"><a href="#leave" class="headerlink" title="leave"></a>leave</h3><p><code>leave</code>指令触发一个优雅的离开动作并关闭agent, 节点离开后不会尝试重新加入集群中. 运行在server状态的节点, 节点会被优雅的删除, 这是很严重的, 在某些情况下一个不优雅的离开会影响到集群的可用性. </p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">-rpc-addr</span><span class="token punctuation">:</span> 一个rpc地址<span class="token punctuation">,</span> agent可以链接上来发送命令<span class="token punctuation">,</span> 如果没有指定<span class="token punctuation">,</span> 默认是127.0.0.1<span class="token punctuation">:</span><span class="token number">8400.</span> <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="members"><a href="#members" class="headerlink" title="members"></a>members</h3><p><code>members</code>指令输出consul agent目前所知道的所有的成员以及它们的状态, 节点的状态只有alive、left、failed三种状态. </p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">-detailed</span><span class="token punctuation">:</span> 输出每个节点更详细的信息. <span class="token key atrule">-rpc-addr</span><span class="token punctuation">:</span> 一个rpc地址<span class="token punctuation">,</span> agent可以链接上来发送命令<span class="token punctuation">,</span> 如果没有指定<span class="token punctuation">,</span> 默认是127.0.0.1<span class="token punctuation">:</span><span class="token number">8400.</span> <span class="token key atrule">-status</span><span class="token punctuation">:</span> 过滤出符合正则规则的节点<span class="token key atrule">-wan</span><span class="token punctuation">:</span> xxxxxx<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="monitor"><a href="#monitor" class="headerlink" title="monitor"></a>monitor</h3><p><code>monitor</code>指令用来链接运行的agent, 并显示日志. monitor会显示最近的日志, 并持续的显示日志流, 不会自动退出, 除非你手动或者远程agent自己退出. </p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">-log-level</span><span class="token punctuation">:</span> 显示哪个级别的日志<span class="token punctuation">,</span> 默认是info<span class="token key atrule">-rpc-addr</span><span class="token punctuation">:</span> 一个rpc地址<span class="token punctuation">,</span> agent可以链接上来发送命令<span class="token punctuation">,</span> 如果没有指定<span class="token punctuation">,</span> 默认是127.0.0.1<span class="token punctuation">:</span><span class="token number">8400</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="reload"><a href="#reload" class="headerlink" title="reload"></a>reload</h3><p><code>reload</code>指令可以重新加载agent的配置文件. SIGHUP指令在重新加载配置文件时使用, 任何重新加载的错误都会写在agent的log文件中, 并不会打印到屏幕. </p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">-rpc-addr</span><span class="token punctuation">:</span> 一个rpc地址<span class="token punctuation">,</span> agent可以链接上来发送命令<span class="token punctuation">,</span> 如果没有指定<span class="token punctuation">,</span> 默认是127.0.0.1<span class="token punctuation">:</span><span class="token number">8400</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="version"><a href="#version" class="headerlink" title="version"></a>version</h3><p>打印consul的版本</p><h3 id="watch"><a href="#watch" class="headerlink" title="watch"></a>watch</h3><p><code>watch</code>指令提供了一个机制, 用来监视实际数据视图的改变(节点列表、成员服务、KV), 如果没有指定进程, 当前值会被dump出来</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">-http-addr</span><span class="token punctuation">:</span> http服务的地址<span class="token punctuation">,</span> agent可以链接上来发送命令<span class="token punctuation">,</span> 如果没有设置<span class="token punctuation">,</span> 则默认是127.0.0.1<span class="token punctuation">:</span><span class="token number">8500.</span> <span class="token key atrule">-datacenter</span><span class="token punctuation">:</span> 数据中心查询. <span class="token key atrule">-token</span><span class="token punctuation">:</span> ACL token<span class="token key atrule">-key</span><span class="token punctuation">:</span> 监视key<span class="token punctuation">,</span> 只针对key类型<span class="token key atrule">-name</span><span class="token punctuation">:</span> 监视event<span class="token punctuation">,</span> 只针对event类型<span class="token key atrule">-prefix</span><span class="token punctuation">:</span> 监视key prefix<span class="token punctuation">,</span> 只针对keyprefix类型<span class="token key atrule">-service</span><span class="token punctuation">:</span> 监控service<span class="token punctuation">,</span> 只针对service类型<span class="token key atrule">-state</span><span class="token punctuation">:</span> 过略check state<span class="token key atrule">-tag</span><span class="token punctuation">:</span> 过滤service tag<span class="token key atrule">-type</span><span class="token punctuation">:</span> 监控类型<span class="token punctuation">,</span> 一般有key、keyprefix、service、nodes、checks、event<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="Consul-配置"><a href="#Consul-配置" class="headerlink" title="Consul 配置"></a>Consul 配置</h2><p>agent有各种各样的配置项可以在命令行或者配置文件进行定义, 所有的配置项都是可选择的, 当加载配置文件的时候, consul从配置文件或者配置目录加载配置. 后面定义的配置会合并前面定义的配置, 但是大多数情况下, 合并的意思是后面定义的配置会覆盖前面定义的配置, 但是有些情况, 例如event句柄, 合并仅仅是添加到前面定义的句柄后面. consul重新加载配置文件也支持以信号的方式接收update信号. </p><p>下面看看命令行参数: </p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">-advertise</span><span class="token punctuation">:</span> 通知展现地址用来改变我们给集群中的其他节点展现的地址<span class="token punctuation">,</span> 一般情况下<span class="token punctuation">-</span>bind地址就是展现地址<span class="token key atrule">-bootstrap</span><span class="token punctuation">:</span> 用来控制一个server是否在bootstrap模式<span class="token punctuation">,</span> 在一个datacenter中只能有一个server处于bootstrap模式<span class="token punctuation">,</span> 当一个server处于bootstrap模式时<span class="token punctuation">,</span> 可以自己选举为raft leader. <span class="token key atrule">-bootstrap-expect</span><span class="token punctuation">:</span> 在一个datacenter中期望提供的server节点数目<span class="token punctuation">,</span> 当该值提供的时候<span class="token punctuation">,</span> consul一直等到达到指定sever数目的时候才会引导整个集群<span class="token punctuation">,</span> 该标记不能和bootstrap公用<span class="token key atrule">-bind</span><span class="token punctuation">:</span> 该地址用来在集群内部的通讯<span class="token punctuation">,</span> 集群内的所有节点到地址都必须是可达的<span class="token punctuation">,</span> 默认是0.0.0.0<span class="token key atrule">-client</span><span class="token punctuation">:</span> consul绑定在哪个client地址上<span class="token punctuation">,</span> 这个地址提供HTTP、DNS、RPC等服务<span class="token punctuation">,</span> 默认是127.0.0.1<span class="token key atrule">-config-file</span><span class="token punctuation">:</span> 明确的指定要加载哪个配置文件<span class="token key atrule">-config-dir</span><span class="token punctuation">:</span> 配置文件目录<span class="token punctuation">,</span> 里面所有以.json结尾的文件都会被加载<span class="token key atrule">-data-dir</span><span class="token punctuation">:</span> 提供一个目录用来存放agent的状态<span class="token punctuation">,</span> 所有的agent允许都需要该目录<span class="token punctuation">,</span> 该目录必须是稳定的<span class="token punctuation">,</span> 系统重启后都继续存在<span class="token key atrule">-dc</span><span class="token punctuation">:</span> 该标记控制agent允许的datacenter的名称<span class="token punctuation">,</span> 默认是dc1<span class="token key atrule">-encrypt</span><span class="token punctuation">:</span> 指定secret key<span class="token punctuation">,</span> 使consul在通讯时进行加密<span class="token punctuation">,</span> key可以通过consul keygen生成<span class="token punctuation">,</span> 同一个集群中的节点必须使用相同的key<span class="token key atrule">-join</span><span class="token punctuation">:</span> 加入一个已经启动的agent的ip地址<span class="token punctuation">,</span> 可以多次指定多个agent的地址. 如果consul不能加入任何指定的地址中<span class="token punctuation">,</span> 则agent会启动失败<span class="token punctuation">,</span> 默认agent启动时不会加入任何节点. <span class="token key atrule">-retry-join</span><span class="token punctuation">:</span> 和join类似<span class="token punctuation">,</span> 但是允许你在第一次失败后进行尝试. <span class="token key atrule">-retry-interval</span><span class="token punctuation">:</span> 两次join之间的时间间隔<span class="token punctuation">,</span> 默认是30s<span class="token key atrule">-retry-max</span><span class="token punctuation">:</span> 尝试重复join的次数<span class="token punctuation">,</span> 默认是0<span class="token punctuation">,</span> 也就是无限次尝试<span class="token key atrule">-log-level</span><span class="token punctuation">:</span> consul agent启动后显示的日志信息级别. 默认是info<span class="token punctuation">,</span> <span class="token key atrule">可选</span><span class="token punctuation">:</span> trace、debug、info、warn、err. <span class="token key atrule">-node</span><span class="token punctuation">:</span> 节点在集群中的名称<span class="token punctuation">,</span> 在一个集群中必须是唯一的<span class="token punctuation">,</span> 默认是该节点的主机名<span class="token key atrule">-protocol</span><span class="token punctuation">:</span> consul使用的协议版本<span class="token key atrule">-rejoin</span><span class="token punctuation">:</span> 使consul忽略先前的离开<span class="token punctuation">,</span> 在再次启动后仍旧尝试加入集群中. <span class="token key atrule">-server</span><span class="token punctuation">:</span> 定义agent运行在server模式<span class="token punctuation">,</span> 每个集群至少有一个server<span class="token punctuation">,</span> 建议每个集群的server不要超过5个<span class="token key atrule">-syslog</span><span class="token punctuation">:</span> 开启系统日志功能<span class="token punctuation">,</span> 只在linux/osx上生效<span class="token punctuation">-</span>ui<span class="token punctuation">-</span>dir<span class="token punctuation">:</span>提供存放web ui资源的路径<span class="token punctuation">,</span> 该目录必须是可读的<span class="token punctuation">-</span>pid<span class="token punctuation">-</span>file<span class="token punctuation">:</span>提供一个路径来存放pid文件<span class="token punctuation">,</span> 可以使用该文件进行SIGINT/SIGHUP(关闭/更新)agent<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>除了命令行参数外, 配置也可以写入文件中, 在某些情况下配置文件会更简单一些, 例如: 利用consul被用来管理系统. 配置文件是json格式的, 很容易编写. 配置文件不仅被用来设置agent的启动, 也可以用来提供健康检测和服务发现的定义. 配置文件的一般样例如下: </p><pre class="line-numbers language-json" data-language="json"><code class="language-json"><span class="token punctuation">{</span>  <span class="token property">"datacenter"</span><span class="token operator">:</span> <span class="token string">"dc1"</span><span class="token punctuation">,</span>  <span class="token property">"data_dir"</span><span class="token operator">:</span> <span class="token string">"/opt/consul"</span><span class="token punctuation">,</span>  <span class="token property">"log_level"</span><span class="token operator">:</span> <span class="token string">"INFO"</span><span class="token punctuation">,</span>  <span class="token property">"node_name"</span><span class="token operator">:</span> <span class="token string">"s1"</span><span class="token punctuation">,</span>  <span class="token property">"server"</span><span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>  <span class="token property">"bootstrap_expect"</span><span class="token operator">:</span> <span class="token number">3</span><span class="token punctuation">,</span>  <span class="token property">"bind_addr"</span><span class="token operator">:</span> <span class="token string">"10.201.102.198"</span><span class="token punctuation">,</span>  <span class="token property">"client_addr"</span><span class="token operator">:</span> <span class="token string">"0.0.0.0"</span><span class="token punctuation">,</span>  <span class="token property">"ui_dir"</span><span class="token operator">:</span> <span class="token string">"/root/consul_ui"</span><span class="token punctuation">,</span>  <span class="token property">"retry_join"</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">"10.201.102.198"</span><span class="token punctuation">,</span><span class="token string">"10.201.102.199"</span><span class="token punctuation">,</span><span class="token string">"10.201.102.200"</span><span class="token punctuation">,</span><span class="token string">"10.201.102.248"</span><span class="token punctuation">]</span><span class="token punctuation">,</span>  <span class="token property">"retry_interval"</span><span class="token operator">:</span> <span class="token string">"30s"</span><span class="token punctuation">,</span>  <span class="token property">"enable_debug"</span><span class="token operator">:</span> <span class="token boolean">false</span><span class="token punctuation">,</span>  <span class="token property">"rejoin_after_leave"</span><span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>  <span class="token property">"start_join"</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">"10.201.102.198"</span><span class="token punctuation">,</span><span class="token string">"10.201.102.199"</span><span class="token punctuation">,</span><span class="token string">"10.201.102.200"</span><span class="token punctuation">,</span><span class="token string">"10.201.102.248"</span><span class="token punctuation">]</span><span class="token punctuation">,</span>  <span class="token property">"enable_syslog"</span><span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>  <span class="token property">"syslog_facility"</span><span class="token operator">:</span> <span class="token string">"local5"</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>下面看看详细的配置文件参数: </p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">acl_datacenter</span><span class="token punctuation">:</span> 只用于server<span class="token punctuation">,</span> 指定的datacenter的权威ACL信息<span class="token punctuation">,</span> 所有的servers和datacenter必须同意ACL datacenter<span class="token key atrule">acl_default_policy</span><span class="token punctuation">:</span> 默认是allow<span class="token key atrule">acl_down_policy</span><span class="token punctuation">:</span> <span class="token key atrule">acl_master_token</span><span class="token punctuation">:</span> <span class="token key atrule">acl_token</span><span class="token punctuation">:</span> agent会使用这个token和consul server进行请求<span class="token key atrule">acl_ttl</span><span class="token punctuation">:</span> 控制TTL的cache<span class="token punctuation">,</span> 默认是30s<span class="token key atrule">addresses</span><span class="token punctuation">:</span> 一个嵌套对象<span class="token punctuation">,</span> <span class="token key atrule">可以设置以下key</span><span class="token punctuation">:</span> dns、http、rpc<span class="token key atrule">advertise_addr</span><span class="token punctuation">:</span> 等同于<span class="token punctuation">-</span>advertise<span class="token key atrule">bootstrap</span><span class="token punctuation">:</span> 等同于<span class="token punctuation">-</span>bootstrap<span class="token key atrule">bootstrap_expect</span><span class="token punctuation">:</span> 等同于<span class="token punctuation">-</span>bootstrap<span class="token punctuation">-</span>expect<span class="token key atrule">bind_addr</span><span class="token punctuation">:</span> 等同于<span class="token punctuation">-</span>bind<span class="token key atrule">ca_file</span><span class="token punctuation">:</span> 提供CA文件路径<span class="token punctuation">,</span> 用来检查客户端或者服务端的链接<span class="token key atrule">cert_file</span><span class="token punctuation">:</span> 必须和key_file一起<span class="token key atrule">check_update_interval</span><span class="token punctuation">:</span> <span class="token key atrule">client_addr</span><span class="token punctuation">:</span> 等同于<span class="token punctuation">-</span>client<span class="token key atrule">datacenter</span><span class="token punctuation">:</span> 等同于<span class="token punctuation">-</span>dc<span class="token key atrule">data_dir</span><span class="token punctuation">:</span> 等同于<span class="token punctuation">-</span>data<span class="token punctuation">-</span>dir<span class="token key atrule">disable_anonymous_signature</span><span class="token punctuation">:</span> 在进行更新检查时禁止匿名签名<span class="token key atrule">disable_remote_exec</span><span class="token punctuation">:</span> 禁止支持远程执行<span class="token punctuation">,</span> 设置为true<span class="token punctuation">,</span> agent会忽视所有进入的远程执行请求<span class="token key atrule">disable_update_check</span><span class="token punctuation">:</span> 禁止自动检查安全公告和新版本信息<span class="token key atrule">dns_config</span><span class="token punctuation">:</span> 是一个嵌套对象<span class="token punctuation">,</span> <span class="token key atrule">可以设置以下参数</span><span class="token punctuation">:</span> allow_stale、max_stale、node_ttl 、service_ttl、enable_truncate<span class="token key atrule">domain</span><span class="token punctuation">:</span> 默认情况下consul在进行DNS查询时<span class="token punctuation">,</span> 查询的是consul域<span class="token punctuation">,</span> 可以通过该参数进行修改<span class="token key atrule">enable_debug</span><span class="token punctuation">:</span> 开启debug模式<span class="token key atrule">enable_syslog</span><span class="token punctuation">:</span> 等同于<span class="token punctuation">-</span>syslog<span class="token key atrule">encrypt</span><span class="token punctuation">:</span> 等同于<span class="token punctuation">-</span>encrypt<span class="token key atrule">key_file</span><span class="token punctuation">:</span> 提供私钥的路径<span class="token key atrule">leave_on_terminate</span><span class="token punctuation">:</span> 默认是false<span class="token punctuation">,</span> 如果为true<span class="token punctuation">,</span> 当agent收到一个TERM信号的时候<span class="token punctuation">,</span> 它会发送leave信息到集群中的其他节点上. <span class="token key atrule">log_level</span><span class="token punctuation">:</span> 等同于<span class="token punctuation">-</span>log<span class="token punctuation">-</span>level<span class="token key atrule">node_name</span><span class="token punctuation">:</span> 等同于<span class="token punctuation">-</span>node<span class="token key atrule">ports</span><span class="token punctuation">:</span> 这是一个嵌套对象<span class="token punctuation">,</span> <span class="token key atrule">可以设置以下key</span><span class="token punctuation">:</span> <span class="token key atrule">dns(dns地址</span><span class="token punctuation">:</span> <span class="token key atrule">8600)、http(http api地址</span><span class="token punctuation">:</span> 8500)、rpc(rpc<span class="token punctuation">:</span>8400)、serf_lan(lan port<span class="token punctuation">:</span>8301)、serf_wan(wan port<span class="token punctuation">:</span>8302)、server(server rpc<span class="token punctuation">:</span>8300)<span class="token key atrule">protocol</span><span class="token punctuation">:</span> 等同于<span class="token punctuation">-</span>protocol<span class="token key atrule">recursor</span><span class="token punctuation">:</span> <span class="token key atrule">rejoin_after_leave</span><span class="token punctuation">:</span> 等同于<span class="token punctuation">-</span>rejoin<span class="token key atrule">retry_join</span><span class="token punctuation">:</span> 等同于<span class="token punctuation">-</span>retry<span class="token punctuation">-</span>join<span class="token key atrule">retry_interval</span><span class="token punctuation">:</span> 等同于<span class="token punctuation">-</span>retry<span class="token punctuation">-</span>interval<span class="token key atrule">server</span><span class="token punctuation">:</span> 等同于<span class="token punctuation">-</span>server<span class="token key atrule">server_name</span><span class="token punctuation">:</span> 会覆盖TLS CA的node_name<span class="token punctuation">,</span> 可以用来确认CA name和hostname相匹配<span class="token key atrule">skip_leave_on_interrupt</span><span class="token punctuation">:</span> 和leave_on_terminate比较类似<span class="token punctuation">,</span> 不过只影响当前句柄<span class="token key atrule">start_join</span><span class="token punctuation">:</span> 一个字符数组提供的节点地址会在启动时被加入<span class="token key atrule">statsd_addr</span><span class="token punctuation">:</span> <span class="token key atrule">statsite_addr</span><span class="token punctuation">:</span> <span class="token key atrule">syslog_facility</span><span class="token punctuation">:</span> 当enable_syslog被提供后<span class="token punctuation">,</span> 该参数控制哪个级别的信息被发送<span class="token punctuation">,</span> 默认Local0<span class="token key atrule">ui_dir</span><span class="token punctuation">:</span> 等同于<span class="token punctuation">-</span>ui<span class="token punctuation">-</span>dir<span class="token key atrule">verify_incoming</span><span class="token punctuation">:</span> 默认false<span class="token punctuation">,</span> 如果为true<span class="token punctuation">,</span> 则所有进入链接都需要使用TLS<span class="token punctuation">,</span> 需要客户端使用ca_file提供ca文件<span class="token punctuation">,</span> 只用于consul server端<span class="token punctuation">,</span> 因为client从来没有进入的链接<span class="token key atrule">verify_outgoing</span><span class="token punctuation">:</span> 默认false<span class="token punctuation">,</span> 如果为true<span class="token punctuation">,</span> 则所有出去链接都需要使用TLS<span class="token punctuation">,</span> 需要服务端使用ca_file提供ca文件<span class="token punctuation">,</span> consul server和client都需要使用<span class="token punctuation">,</span> 因为两者都有出去的链接<span class="token key atrule">watches</span><span class="token punctuation">:</span> watch一个详细名单<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>##HTTP API<br>consul的主要接口是RESTful HTTP API, 该API可以用来增删查改nodes、services、checks、configguration. 所有的endpoints主要分为以下类别: </p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">kv - Key/Value存储agent - Agent控制catalog - 管理nodes和serviceshealth - 管理健康监测session - Session操作acl - ACL创建和管理event - 用户Eventsstatus - Consul系统状态<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>下面我们就单独看看每个模块的具体内容. </p><h3 id="agent"><a href="#agent" class="headerlink" title="agent"></a>agent</h3><p>agent endpoints用来和本地agent进行交互, 一般用来服务注册和检查注册, 支持以下接口</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">/v1/agent/checks</span> <span class="token punctuation">:</span> 返回本地agent注册的所有检查(包括配置文件和HTTP接口)<span class="token key atrule">/v1/agent/services</span> <span class="token punctuation">:</span> 返回本地agent注册的所有 服务<span class="token key atrule">/v1/agent/members</span> <span class="token punctuation">:</span> 返回agent在集群的gossip pool中看到的成员<span class="token key atrule">/v1/agent/self</span> <span class="token punctuation">:</span> 返回本地agent的配置和成员信息<span class="token key atrule">/v1/agent/join/&lt;address&gt;</span> <span class="token punctuation">:</span> 触发本地agent加入node<span class="token key atrule">/v1/agent/force-leave/&lt;node&gt;&gt;</span><span class="token punctuation">:</span> 强制删除node<span class="token key atrule">/v1/agent/check/register</span> <span class="token punctuation">:</span> 在本地agent增加一个检查项<span class="token punctuation">,</span> 使用PUT方法传输一个json格式的数据<span class="token key atrule">/v1/agent/check/deregister/&lt;checkID&gt;</span> <span class="token punctuation">:</span> 注销一个本地agent的检查项<span class="token key atrule">/v1/agent/check/pass/&lt;checkID&gt;</span> <span class="token punctuation">:</span> 设置一个本地检查项的状态为passing<span class="token key atrule">/v1/agent/check/warn/&lt;checkID&gt;</span> <span class="token punctuation">:</span> 设置一个本地检查项的状态为warning<span class="token key atrule">/v1/agent/check/fail/&lt;checkID&gt;</span> <span class="token punctuation">:</span> 设置一个本地检查项的状态为critical<span class="token key atrule">/v1/agent/service/register</span> <span class="token punctuation">:</span> 在本地agent增加一个新的服务项<span class="token punctuation">,</span> 使用PUT方法传输一个json格式的数据<span class="token key atrule">/v1/agent/service/deregister/&lt;serviceID&gt;</span> <span class="token punctuation">:</span> 注销一个本地agent的服务项<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="catalog"><a href="#catalog" class="headerlink" title="catalog"></a>catalog</h3><p>catalog endpoints用来注册/注销nodes、services、checks</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">/v1/catalog/register</span> <span class="token punctuation">:</span> Registers a new node<span class="token punctuation">,</span> service<span class="token punctuation">,</span> or check<span class="token key atrule">/v1/catalog/deregister</span> <span class="token punctuation">:</span> Deregisters a node<span class="token punctuation">,</span> service<span class="token punctuation">,</span> or check<span class="token key atrule">/v1/catalog/datacenters</span> <span class="token punctuation">:</span> Lists known datacenters<span class="token key atrule">/v1/catalog/nodes</span> <span class="token punctuation">:</span> Lists nodes in a given DC<span class="token key atrule">/v1/catalog/services</span> <span class="token punctuation">:</span> Lists services in a given DC<span class="token key atrule">/v1/catalog/service/&lt;service&gt;</span> <span class="token punctuation">:</span> Lists the nodes in a given service<span class="token key atrule">/v1/catalog/node/&lt;node&gt;</span> <span class="token punctuation">:</span> Lists the services provided by a node<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="health"><a href="#health" class="headerlink" title="health"></a>health</h3><p>health endpoints用来查询健康状况相关信息, 该功能从catalog中单独分离出来</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">/v1/healt/node/&lt;node&gt;</span><span class="token punctuation">:</span> 返回node所定义的检查<span class="token punctuation">,</span> 可用参数<span class="token punctuation">?</span>dc=<span class="token key atrule">/v1/health/checks/&lt;service&gt;</span><span class="token punctuation">:</span> 返回和服务相关联的检查<span class="token punctuation">,</span> 可用参数<span class="token punctuation">?</span>dc=<span class="token key atrule">/v1/health/service/&lt;service&gt;</span><span class="token punctuation">:</span> 返回给定datacenter中给定node中service<span class="token key atrule">/v1/health/state/&lt;state&gt;</span><span class="token punctuation">:</span> 返回给定datacenter中指定状态的服务<span class="token punctuation">,</span> state可以是"any"<span class="token punctuation">,</span> <span class="token string">"unknown"</span><span class="token punctuation">,</span> <span class="token string">"passing"</span><span class="token punctuation">,</span> <span class="token string">"warning"</span><span class="token punctuation">,</span> or "critical"<span class="token punctuation">,</span> 可用参数<span class="token punctuation">?</span>dc=<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="session"><a href="#session" class="headerlink" title="session"></a>session</h3><p>session endpoints用来create、update、destory、query sessions</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">/v1/session/create</span><span class="token punctuation">:</span> Creates a new session<span class="token key atrule">/v1/session/destroy/&lt;session&gt;</span><span class="token punctuation">:</span> Destroys a given session<span class="token key atrule">/v1/session/info/&lt;session&gt;</span><span class="token punctuation">:</span> Queries a given session<span class="token key atrule">/v1/session/node/&lt;node&gt;</span><span class="token punctuation">:</span> Lists sessions belonging to a node<span class="token key atrule">/v1/session/list</span><span class="token punctuation">:</span> Lists all the active sessions<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="acl"><a href="#acl" class="headerlink" title="acl"></a>acl</h3><p>acl endpoints用来create、update、destory、query acl</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">/v1/acl/create: Creates a new token with policy/v1/acl/update: Update the policy of a token/v1/acl/destroy/&lt;id&gt;: Destroys a given token/v1/acl/info/&lt;id&gt;: Queries the policy of a given token/v1/acl/clone/&lt;id&gt;: Creates a new token by cloning an existing token/v1/acl/list: Lists all the active tokens<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="event-1"><a href="#event-1" class="headerlink" title="event"></a>event</h3><p>event endpoints用来fire新的events、查询已有的events</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">/v1/event/fire/&lt;name&gt;</span><span class="token punctuation">:</span> 触发一个新的event<span class="token punctuation">,</span> 用户event需要name和其他可选的参数<span class="token punctuation">,</span> 使用PUT方法<span class="token key atrule">/v1/event/list</span><span class="token punctuation">:</span> 返回agent知道的events<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="status"><a href="#status" class="headerlink" title="status"></a>status</h3><p>status endpoints用来或者consul 集群的信息</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">/v1/status/leader</span> <span class="token punctuation">:</span> 返回当前集群的Raft leader<span class="token key atrule">/v1/status/peers</span> <span class="token punctuation">:</span> 返回当前集群中同事<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="Consul-Template"><a href="#Consul-Template" class="headerlink" title="Consul-Template"></a>Consul-Template</h2><p>在consul-template没出现之前, 大家构建服务发现系统, 大多采用的是zookeeper、etcd+confd这样类似的系统, 之前写过一篇consul+confd的文, 讲的是如何动态生成配置文件的, 如今consul官方推出了自己的模板系统, 就是consul-template, 这样的话动态的配置系统可以分化为etcd+confd和consul+consul-template两大阵营. consul是一个和etcd类似但又强于etcd的系统, 关于etcd和consul可以翻阅以前的文章, consul-template的定位就和confd差不多一样了, confd的后端可以是etcd或者consul, 相信consul搭配consul-template能发挥更大的效果. consul-template提供了一个便捷的方式从consul中获取存储的值, consul-template守护进程会查询consul实例, 来更新系统上指定的任何模板, 当更新完成后, 模板可以选择运行一些任意的命令. </p><p>consul template的使用场景: consul template可以查询consul中的服务目录、key、key-values等. 这种强大的抽象功能和查询语言模板可以使consul template特别适合动态的创建配置文件. 例如: 创建apache/nginx proxy balancers、haproxy backends、varnish servers、application configurations. </p><p>consul template的特性:</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">quiescence</span><span class="token punctuation">:</span> consul template内制静止平衡功能<span class="token punctuation">,</span> 可以智能的发现consul实例中的更改信息. 这个功能可以防止频繁的更新模板而引起系统的波动. <span class="token key atrule">dry mode</span><span class="token punctuation">:</span> 不确定当前架构的状态？担心模板的变化会破坏子系统？无须担心<span class="token punctuation">,</span> 因为consul template还有<span class="token punctuation">-</span>dry模式. 在dry模式<span class="token punctuation">,</span> consul template会将结果呈现在STDOUT<span class="token punctuation">,</span> 所以操作员可以检查输出是否正常<span class="token punctuation">,</span> 以决定更换模板是否安全<span class="token key atrule">CLI and Config</span><span class="token punctuation">:</span> 如果你喜欢在命令行上指定一切<span class="token punctuation">,</span> consul template都可以hold住. 随着内置HCL的支持<span class="token punctuation">,</span> consul template接收一个配置文件<span class="token punctuation">,</span> 命令行参数<span class="token punctuation">,</span> 或者两者的混合. 通过这种方式你可以继续使用你现在已有的配置管理工具和consul template来配合. <span class="token key atrule">verbose debugging</span><span class="token punctuation">:</span> 即使每件事你都做的近乎完美<span class="token punctuation">,</span> 但是有时候还是会有失败发生. consul template可以提供更详细的debug日志信息. <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>你可以在发布页下载发布包.如果你希望自己编译请查看说明文档.</p><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">-auth=&lt;user[:pass]&gt;      设置基本的认证用户名和密码-consul-addr=&lt;address&gt;   设置Consul实例的地址-max-stale=&lt;duration&gt;    查询过期的最大频率, 默认是1s-dedup                   启用重复数据删除, 当许多consul template实例渲染一个模板的时候可以降低consul的负载-ssl                     使用https连接Consul使用SSL-ssl-verify              通过SSL连接的时候检查证书-ssl-cert                SSL客户端证书发送给服务器-ssl-key                 客户端认证时使用的SSL/TLS私钥-ssl-ca-cert             验证服务器的CA证书列表-token=&lt;token&gt;           设置Consul API的token-syslog                  把标准输出和标准错误重定向到syslog, syslog的默认级别是local0. -syslog-facility=&lt;f&gt;     设置syslog级别, 默认是local0, 必须和-syslog配合使用-template=&lt;template&gt;     增加一个需要监控的模板, 格式是: 'templatePath:outputPath(:command)', 多个模板则可以设置多次-wait=&lt;duration&gt;         当呈现一个新的模板到系统和触发一个命令的时候, 等待的最大最小时间. 如果最大值被忽略, 默认是最小值的4倍. -retry=&lt;duration&gt;        当在和consul api交互的返回值是error的时候, 等待的时间, 默认是5s. -config=&lt;path&gt;           配置文件或者配置目录的路径-pid-file=&lt;path&gt;         PID文件的路径-log-level=&lt;level&gt;       设置日志级别, 可以是"debug","info", "warn" (default), and "err"-dry                     Dump生成的模板到标准输出, 不会生成到磁盘-once                    运行consul-template一次后退出, 不以守护进程运行-reap                    子进程自动收割<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>查看全部选项,使用以下命令</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">consul-template -h<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="命令行"><a href="#命令行" class="headerlink" title="命令行"></a>命令行</h3><ol><li>查询本地consl实例, 生成模板后重启nginx, 如果consul不可用, 如果api故障则每30s尝试检测一次值, consul-template运行一次后退出</li></ol><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">consul-template -retry 30s -once -consul-addr=10.201.102.198:8500 -template "test.ctmpl:test.out"<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>test.ctmpl</strong></p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">{{range service "Faceid"}}{{.ID}} {{.Address}}:{{.Port}} check inter 5000 fall 1 rise 2 weight 2{{end}}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong>test.out</strong></p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">Faceid 10.201.102.198:9000 check inter 5000 fall 1 rise 2 weight 2Faceid 10.201.102.199:9000 check inter 5000 fall 1 rise 2 weight 2Faceid 10.201.102.200:9000 check inter 5000 fall 1 rise 2 weight 2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ol start="2"><li><p>运行consul-temple作为一个服务</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">consul-template -consul-addr=10.201.102.198:8500 -template "test.ctmpl:test.out"<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>查询一个实例, 渲染多个模板, 然后重启相关服务</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">consul-template -retry 30s -once -consul-addr=10.201.102.198:8500 -template "test.ctmpl:test.out"\ -template "/tmp/redis.ctmpl:/var/redis/redis.conf:service redis restart" \ -template "/tmp/haproxy.ctmpl:/var/haproxy/haproxy.conf"<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li><p>查询一个实例, dump模板到标准输出, 参数中的-template则会被忽略</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">consul-template -dry -consul-addr=10.201.102.198:8500 -template "test.ctmpl:test.out"<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>以上参数除了在命令行使用, 也可以直接配置在文件中, 下面看看Consul-Template的配置文件, 简称HCL(HashiCorp Configuration Language), 它是和JSON兼容的, 下面看个例子: </p><h4 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h4></li></ol><p>Consul-Template 配置文件是使用<a href="https://github.com/hashicorp/hcl">HashiCorp Configuration Language (HCL)</a>编写的.这意味着<code>Consul Template</code>是和JSON兼容的,查看更多信息请查看 <a href="https://github.com/hashicorp/hcl">HCL 规范</a></p><p>配置文件语法支持上面的所有的选项,除非在表格中进行标明.</p><pre class="line-numbers language-vim" data-language="vim"><code class="language-vim"><span class="token operator">/</span><span class="token operator">/</span> 这是要连接的Consul Agent的地址<span class="token operator">.</span>默认为<span class="token number">127.0</span><span class="token operator">.</span><span class="token number">0.1</span><span class="token punctuation">:</span><span class="token number">8500</span><span class="token operator">.</span>这是Consul的默认绑定地址和端口<span class="token operator">.</span><span class="token operator">/</span><span class="token operator">/</span> 不建议你直接与 Consul的 Server直接进行交互<span class="token punctuation">,</span>请与本地的Consul Agent进行交互<span class="token operator">.</span>这样做是有一些原因<span class="token operator">/</span><span class="token operator">/</span> 最重要的是本地agent可以复用与server的连接<span class="token operator">.</span>减少HTTP的连接数<span class="token operator">.</span>另外这个地址更好记<span class="token operator">.</span>consul <span class="token operator">=</span> <span class="token string">"127.0.0.1:8500"</span><span class="token operator">/</span><span class="token operator">/</span> 这是用于连接Consul的ACL token<span class="token operator">.</span> 如果你的集群未启用就不需要设置<span class="token operator">.</span><span class="token operator">/</span><span class="token operator">/</span><span class="token operator">/</span><span class="token operator">/</span> 这个选项也可以通过环境变量 CONSUL_TOKEN 来进行设置token <span class="token operator">=</span> <span class="token string">"abcd1234"</span><span class="token operator">/</span><span class="token operator">/</span> 这是监听出发reload事件的信号<span class="token punctuation">,</span>默认值如下所示<span class="token operator">.</span>将这个值设置为空将引起 CT <span class="token punctuation">,</span>从而不监听reload事件reload_signal <span class="token operator">=</span> <span class="token string">"SIGHUP"</span><span class="token operator">/</span><span class="token operator">/</span> 这是监听出发core dump事件的信号<span class="token punctuation">,</span>默认值如下所示<span class="token operator">.</span>将这个值设置为空将引起 CT <span class="token punctuation">,</span>从而不监听core dump信号dump_signal <span class="token operator">=</span> <span class="token string">"SIGQUIT"</span><span class="token operator">/</span><span class="token operator">/</span> 这是监听出发graceful <span class="token keyword">stop</span>事件的信号<span class="token punctuation">,</span>默认值如下所示<span class="token operator">.</span>将这个值设置为空将引起 CT <span class="token punctuation">,</span>从而不监听graceful <span class="token keyword">stop</span>信号kill_signal <span class="token operator">=</span> <span class="token string">"SIGINT"</span><span class="token operator">/</span><span class="token operator">/</span> 这是连接Consul的重试时间<span class="token operator">.</span>Consul Template是高容错的设计<span class="token operator">.</span>这意味着<span class="token punctuation">,</span>出现失败他不会退出<span class="token operator">.</span>而按照<span class="token operator">/</span><span class="token operator">/</span> 分布式系统的惯例进行指数补偿和重试来等待集群恢复<span class="token operator">.</span>retry <span class="token operator">=</span> <span class="token string">"10s"</span><span class="token operator">/</span><span class="token operator">/</span> This <span class="token operator">is</span> the maximum interval <span class="token keyword">to</span> allow <span class="token string">"stale"</span> data<span class="token operator">.</span> By default<span class="token punctuation">,</span> <span class="token keyword">only</span> the<span class="token operator">/</span><span class="token operator">/</span> Consul leader will respond <span class="token keyword">to</span> queries<span class="token punctuation">;</span> any requests <span class="token keyword">to</span> a follower will<span class="token operator">/</span><span class="token operator">/</span> forward <span class="token keyword">to</span> the leader<span class="token operator">.</span> In large clusters with many requests<span class="token punctuation">,</span> this <span class="token operator">is</span> not <span class="token keyword">as</span><span class="token operator">/</span><span class="token operator">/</span> scalable<span class="token punctuation">,</span> <span class="token keyword">so</span> this option allows any follower <span class="token keyword">to</span> respond <span class="token keyword">to</span> a query<span class="token punctuation">,</span> <span class="token keyword">so</span> long<span class="token operator">/</span><span class="token operator">/</span> <span class="token keyword">as</span> the <span class="token keyword">last</span><span class="token operator">-</span>replicated data <span class="token operator">is</span> within these bounds<span class="token operator">.</span> Higher values result <span class="token keyword">in</span><span class="token operator">/</span><span class="token operator">/</span> less cluster load<span class="token punctuation">,</span> but are <span class="token builtin">more</span> likely <span class="token keyword">to</span> have outdated data<span class="token operator">.</span><span class="token operator">/</span><span class="token operator">/</span> 这是允许陈旧数据的最大时间<span class="token operator">.</span>Consul默认只有领袖对请求进行相应<span class="token operator">.</span>所有对追随者的请求将被转发给领袖<span class="token operator">.</span><span class="token operator">/</span><span class="token operator">/</span> 在有大量请求的大型集群中<span class="token punctuation">,</span>这显得不够有扩展性<span class="token operator">.</span>所以这个选项允许任何追随者响应查询<span class="token punctuation">,</span>只要最后复制的数据<span class="token operator">/</span><span class="token operator">/</span> 在这个范围内<span class="token operator">.</span>数值越高<span class="token punctuation">,</span>越减少集群负载<span class="token punctuation">,</span>但是更容易接受到过期数据<span class="token operator">.</span>max_stale <span class="token operator">=</span> <span class="token string">"10m"</span><span class="token operator">/</span><span class="token operator">/</span> 这是log的等级<span class="token punctuation">,</span>如果你找到了bug<span class="token punctuation">,</span>请打开<span class="token builtin">debug</span> 日志<span class="token punctuation">,</span>这样我们可以更好的定位问题<span class="token operator">.</span>这个选项也可用在命令行<span class="token operator">.</span>log_level <span class="token operator">=</span> <span class="token string">"warn"</span><span class="token operator">/</span><span class="token operator">/</span> 这是存放Consul Template 进程的PID文件的路径<span class="token punctuation">,</span>如果你计划发送定制的信号到这个进程这会比较有用<span class="token operator">.</span>pid_file <span class="token operator">=</span> <span class="token string">"/path/to/pid"</span><span class="token operator">/</span><span class="token operator">/</span> 这是一个静止定时器<span class="token punctuation">,</span>他定义了在模板渲染之前等待集群达到一致状态的最小和最大时间<span class="token operator">.</span><span class="token operator">/</span><span class="token operator">/</span> 这对于一些变化较大的系统中比较有用<span class="token punctuation">,</span>可以减少模板渲染的次数wait <span class="token operator">=</span> <span class="token string">"5s:10s"</span><span class="token operator">/</span><span class="token operator">/</span> 这是 Vault配置的开始<span class="token operator">/</span><span class="token operator">/</span> Vault是HashiCorp的另外一个产品vault <span class="token punctuation">{</span>  <span class="token operator">/</span><span class="token operator">/</span> This <span class="token operator">is</span> the address of the Vault leader<span class="token operator">.</span> The protocol <span class="token punctuation">(</span><span class="token function">http</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">)</span> portion  <span class="token operator">/</span><span class="token operator">/</span> of the address <span class="token operator">is</span> required<span class="token operator">.</span>  address <span class="token operator">=</span> <span class="token string">"https://vault.service.consul:8200"</span>  <span class="token operator">/</span><span class="token operator">/</span> This <span class="token operator">is</span> the token <span class="token keyword">to</span> use when communicating with the Vault server<span class="token operator">.</span>  <span class="token operator">/</span><span class="token operator">/</span> Like other tools that integrate with Vault<span class="token punctuation">,</span> Consul Template makes the  <span class="token operator">/</span><span class="token operator">/</span> assumption that you provide it with a Vault token<span class="token punctuation">;</span> it does not have the  <span class="token operator">/</span><span class="token operator">/</span> incorporated logic <span class="token keyword">to</span> generate tokens via Vault's auth methods<span class="token operator">.</span>  <span class="token operator">/</span><span class="token operator">/</span>  <span class="token operator">/</span><span class="token operator">/</span> This value can also <span class="token keyword">be</span> specified via the environment variable VAULT_TOKEN<span class="token operator">.</span>  token <span class="token operator">=</span> <span class="token string">"abcd1234"</span>  <span class="token operator">/</span><span class="token operator">/</span> This option tells Consul Template <span class="token keyword">to</span> automatically renew the Vault token  <span class="token operator">/</span><span class="token operator">/</span> given<span class="token operator">.</span> If you are unfamiliar with Vault's architecture<span class="token punctuation">,</span> Vault requires  <span class="token operator">/</span><span class="token operator">/</span> tokens <span class="token keyword">be</span> renewed at some regular interval or they will <span class="token keyword">be</span> revoked<span class="token operator">.</span> Consul  <span class="token operator">/</span><span class="token operator">/</span> Template will automatically renew the token at half the lease duration of  <span class="token operator">/</span><span class="token operator">/</span> the token<span class="token operator">.</span> The default value <span class="token operator">is</span> true<span class="token punctuation">,</span> but this option can <span class="token keyword">be</span> disabled <span class="token keyword">if</span>  <span class="token operator">/</span><span class="token operator">/</span> you want <span class="token keyword">to</span> renew the Vault token using an out<span class="token operator">-</span>of<span class="token operator">-</span>band process<span class="token operator">.</span>  <span class="token operator">/</span><span class="token operator">/</span>  <span class="token operator">/</span><span class="token operator">/</span> Note that secrets specified <span class="token keyword">in</span> a template <span class="token punctuation">(</span>using <span class="token punctuation">{</span><span class="token punctuation">{</span>secret<span class="token punctuation">}</span><span class="token punctuation">}</span> <span class="token keyword">for</span> example<span class="token punctuation">)</span>  <span class="token operator">/</span><span class="token operator">/</span> are always renewed<span class="token punctuation">,</span> even <span class="token keyword">if</span> this option <span class="token operator">is</span> <span class="token keyword">set</span> <span class="token keyword">to</span> false<span class="token operator">.</span> This option <span class="token keyword">only</span>  <span class="token operator">/</span><span class="token operator">/</span> applies <span class="token keyword">to</span> the <span class="token builtin">top</span><span class="token operator">-</span>level Vault token itself<span class="token operator">.</span>  renew <span class="token operator">=</span> true  <span class="token operator">/</span><span class="token operator">/</span> This section details the SSL <span class="token keyword">options</span> <span class="token keyword">for</span> connecting <span class="token keyword">to</span> the Vault server<span class="token operator">.</span>  <span class="token operator">/</span><span class="token operator">/</span> Please see the SSL <span class="token keyword">options</span> below <span class="token keyword">for</span> <span class="token builtin">more</span> information <span class="token punctuation">(</span>they are the same<span class="token punctuation">)</span><span class="token operator">.</span>  <span class="token builtin">ssl</span> <span class="token punctuation">{</span>    <span class="token operator">/</span><span class="token operator">/</span> <span class="token operator">.</span><span class="token operator">.</span><span class="token operator">.</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token operator">/</span><span class="token operator">/</span> 这部分配置请求的基本的权限验证信息auth <span class="token punctuation">{</span>  enabled  <span class="token operator">=</span> true  username <span class="token operator">=</span> <span class="token string">"test"</span>  password <span class="token operator">=</span> <span class="token string">"test"</span><span class="token punctuation">}</span><span class="token operator">/</span><span class="token operator">/</span> 这部分配置连接到Consul服务器的SSL信息<span class="token operator">.</span><span class="token builtin">ssl</span> <span class="token punctuation">{</span>  <span class="token operator">/</span><span class="token operator">/</span> 使用SSL需要先打开这个开关  enabled <span class="token operator">=</span> true  <span class="token operator">/</span><span class="token operator">/</span> This enables SSL peer verification<span class="token operator">.</span> The default value <span class="token operator">is</span> <span class="token string">"true"</span><span class="token punctuation">,</span> which  <span class="token operator">/</span><span class="token operator">/</span> will check the global CA chain <span class="token keyword">to</span> <span class="token keyword">make</span> sure the given certificates are  <span class="token operator">/</span><span class="token operator">/</span> valid<span class="token operator">.</span> If you are using a self<span class="token operator">-</span>signed certificate that you have not added  <span class="token operator">/</span><span class="token operator">/</span> <span class="token keyword">to</span> the CA chain<span class="token punctuation">,</span> you may want <span class="token keyword">to</span> disable SSL verification<span class="token operator">.</span> However<span class="token punctuation">,</span> please  <span class="token operator">/</span><span class="token operator">/</span> understand this <span class="token operator">is</span> a potential security vulnerability<span class="token operator">.</span>  verify <span class="token operator">=</span> false  <span class="token operator">/</span><span class="token operator">/</span> This <span class="token operator">is</span> the <span class="token builtin">path</span> <span class="token keyword">to</span> the certificate <span class="token keyword">to</span> use <span class="token keyword">to</span> authenticate<span class="token operator">.</span> If just a  <span class="token operator">/</span><span class="token operator">/</span> certificate <span class="token operator">is</span> provided<span class="token punctuation">,</span> it <span class="token operator">is</span> assumed <span class="token keyword">to</span> contain both the certificate and  <span class="token operator">/</span><span class="token operator">/</span> the <span class="token builtin">key</span> <span class="token keyword">to</span> convert <span class="token keyword">to</span> an X509 certificate<span class="token operator">.</span> If both the certificate and  <span class="token operator">/</span><span class="token operator">/</span> <span class="token builtin">key</span> are specified<span class="token punctuation">,</span> Consul Template will automatically combine them into an  <span class="token operator">/</span><span class="token operator">/</span> X509 certificate <span class="token keyword">for</span> you<span class="token operator">.</span>  cert <span class="token operator">=</span> <span class="token string">"/path/to/client/cert"</span>  <span class="token builtin">key</span> <span class="token operator">=</span> <span class="token string">"/path/to/client/key"</span>  <span class="token operator">/</span><span class="token operator">/</span> This <span class="token operator">is</span> the <span class="token builtin">path</span> <span class="token keyword">to</span> the certificate authority <span class="token keyword">to</span> use <span class="token keyword">as</span> a CA<span class="token operator">.</span> This <span class="token operator">is</span>  <span class="token operator">/</span><span class="token operator">/</span> useful <span class="token keyword">for</span> self<span class="token operator">-</span>signed certificates or <span class="token keyword">for</span> organizations using their own  <span class="token operator">/</span><span class="token operator">/</span> internal certificate authority<span class="token operator">.</span>  ca_cert <span class="token operator">=</span> <span class="token string">"/path/to/ca"</span><span class="token punctuation">}</span><span class="token operator">/</span><span class="token operator">/</span> 设置连接到syslog服务器的配置<span class="token operator">/</span><span class="token operator">/</span> 用于进行日志记录syslog <span class="token punctuation">{</span>  <span class="token operator">/</span><span class="token operator">/</span> 打开开关  enabled <span class="token operator">=</span> true  <span class="token operator">/</span><span class="token operator">/</span> 设备名称  facility <span class="token operator">=</span> <span class="token string">"LOCAL5"</span><span class="token punctuation">}</span><span class="token operator">/</span><span class="token operator">/</span> This block defines the configuration <span class="token keyword">for</span> de<span class="token operator">-</span>duplication <span class="token keyword">mode</span><span class="token operator">.</span> Please see the<span class="token operator">/</span><span class="token operator">/</span> de<span class="token operator">-</span>duplication <span class="token keyword">mode</span> documentation <span class="token keyword">later</span> <span class="token keyword">in</span> the README <span class="token keyword">for</span> <span class="token builtin">more</span> information<span class="token operator">/</span><span class="token operator">/</span> <span class="token keyword">on</span> how de<span class="token operator">-</span>duplication <span class="token keyword">mode</span> operates<span class="token operator">.</span>deduplicate <span class="token punctuation">{</span>  <span class="token operator">/</span><span class="token operator">/</span> This enables de<span class="token operator">-</span>duplication <span class="token keyword">mode</span><span class="token operator">.</span> Specifying any other <span class="token keyword">options</span> also enables  <span class="token operator">/</span><span class="token operator">/</span> de<span class="token operator">-</span>duplication <span class="token keyword">mode</span><span class="token operator">.</span>  enabled <span class="token operator">=</span> true  <span class="token operator">/</span><span class="token operator">/</span> This <span class="token operator">is</span> the prefix <span class="token keyword">to</span> the <span class="token builtin">path</span> <span class="token keyword">in</span> Consul's KV store where de<span class="token operator">-</span>duplication  <span class="token operator">/</span><span class="token operator">/</span> templates will <span class="token keyword">be</span> <span class="token keyword">pre</span><span class="token operator">-</span>rendered and stored<span class="token operator">.</span>  prefix <span class="token operator">=</span> <span class="token string">"consul-template/dedup/"</span><span class="token punctuation">}</span><span class="token operator">/</span><span class="token operator">/</span> This block defines the configuration <span class="token keyword">for</span> exec <span class="token keyword">mode</span><span class="token operator">.</span> Please see the exec <span class="token keyword">mode</span><span class="token operator">/</span><span class="token operator">/</span> documentation at the bottom of this README <span class="token keyword">for</span> <span class="token builtin">more</span> information <span class="token keyword">on</span> how exec<span class="token operator">/</span><span class="token operator">/</span> <span class="token keyword">mode</span> operates and the caveats of this <span class="token keyword">mode</span><span class="token operator">.</span>exec <span class="token punctuation">{</span>  <span class="token operator">/</span><span class="token operator">/</span> This <span class="token operator">is</span> the command <span class="token keyword">to</span> exec <span class="token keyword">as</span> a child process<span class="token operator">.</span> There can <span class="token keyword">be</span> <span class="token keyword">only</span> one  <span class="token operator">/</span><span class="token operator">/</span> command per Consul Template process<span class="token operator">.</span>  command <span class="token operator">=</span> <span class="token string">"/usr/bin/app"</span>  <span class="token operator">/</span><span class="token operator">/</span> This <span class="token operator">is</span> a random splay <span class="token keyword">to</span> wait before killing the command<span class="token operator">.</span> The default  <span class="token operator">/</span><span class="token operator">/</span> value <span class="token operator">is</span> <span class="token number">0</span> <span class="token punctuation">(</span>no wait<span class="token punctuation">)</span><span class="token punctuation">,</span> but large clusters should consider setting a splay  <span class="token operator">/</span><span class="token operator">/</span> value <span class="token keyword">to</span> prevent <span class="token keyword">all</span> child processes from reloading at the same time when  <span class="token operator">/</span><span class="token operator">/</span> data <span class="token keyword">changes</span> occur<span class="token operator">.</span> When this value <span class="token operator">is</span> <span class="token keyword">set</span> <span class="token keyword">to</span> non<span class="token operator">-</span>zero<span class="token punctuation">,</span> Consul Template  <span class="token operator">/</span><span class="token operator">/</span> will wait a random period of time <span class="token keyword">up</span> <span class="token keyword">to</span> the splay value before reloading  <span class="token operator">/</span><span class="token operator">/</span> or killing the child process<span class="token operator">.</span> This can <span class="token keyword">be</span> used <span class="token keyword">to</span> prevent the thundering  <span class="token operator">/</span><span class="token operator">/</span> herd problem <span class="token keyword">on</span> applications that do not gracefully reload<span class="token operator">.</span>  splay <span class="token operator">=</span> <span class="token string">"5s"</span>  <span class="token operator">/</span><span class="token operator">/</span> This defines the signal that will <span class="token keyword">be</span> sent <span class="token keyword">to</span> the child process when a  <span class="token operator">/</span><span class="token operator">/</span> <span class="token keyword">change</span> occurs <span class="token keyword">in</span> a watched template<span class="token operator">.</span> The signal will <span class="token keyword">only</span> <span class="token keyword">be</span> sent after  <span class="token operator">/</span><span class="token operator">/</span> the process <span class="token operator">is</span> started<span class="token punctuation">,</span> and the process will <span class="token keyword">only</span> <span class="token keyword">be</span> started after <span class="token keyword">all</span>  <span class="token operator">/</span><span class="token operator">/</span> dependent templates have been rendered at least once<span class="token operator">.</span> The default value  <span class="token operator">/</span><span class="token operator">/</span> <span class="token operator">is</span> <span class="token string">""</span> <span class="token punctuation">(</span>empty or nil<span class="token punctuation">)</span><span class="token punctuation">,</span> which tells Consul Template <span class="token keyword">to</span> restart the child  <span class="token operator">/</span><span class="token operator">/</span> process instead of sending it a signal<span class="token operator">.</span> This <span class="token operator">is</span> useful <span class="token keyword">for</span> legacy  <span class="token operator">/</span><span class="token operator">/</span> applications or applications that cannot properly reload their  <span class="token operator">/</span><span class="token operator">/</span> configuration without a full reload<span class="token operator">.</span>  reload_signal <span class="token operator">=</span> <span class="token string">"SIGUSR1"</span>  <span class="token operator">/</span><span class="token operator">/</span> This defines the signal sent <span class="token keyword">to</span> the child process when Consul Template <span class="token operator">is</span>  <span class="token operator">/</span><span class="token operator">/</span> gracefully shutting down<span class="token operator">.</span> The application should begin a graceful cleanup<span class="token operator">.</span>  <span class="token operator">/</span><span class="token operator">/</span> If the application does not terminate before the `kill_timeout`<span class="token punctuation">,</span> it will  <span class="token operator">/</span><span class="token operator">/</span> <span class="token keyword">be</span> terminated <span class="token punctuation">(</span>effectively <span class="token string">"kill -9"</span><span class="token punctuation">)</span><span class="token operator">.</span> The default value <span class="token operator">is</span> <span class="token string">"SIGTERM"</span><span class="token operator">.</span>  kill_signal <span class="token operator">=</span> <span class="token string">"SIGINT"</span>  <span class="token operator">/</span><span class="token operator">/</span> This defines the amount of time <span class="token keyword">to</span> wait <span class="token keyword">for</span> the child process <span class="token keyword">to</span> gracefully  <span class="token operator">/</span><span class="token operator">/</span> terminate when Consul Template exits<span class="token operator">.</span> After this specified time<span class="token punctuation">,</span> the child  <span class="token operator">/</span><span class="token operator">/</span> process will <span class="token keyword">be</span> force<span class="token operator">-</span>killed <span class="token punctuation">(</span>effectively <span class="token string">"kill -9"</span><span class="token punctuation">)</span><span class="token operator">.</span> The default value <span class="token operator">is</span>  <span class="token operator">/</span><span class="token operator">/</span> <span class="token string">"30s"</span><span class="token operator">.</span>  kill_timeout <span class="token operator">=</span> <span class="token string">"2s"</span><span class="token punctuation">}</span><span class="token operator">/</span><span class="token operator">/</span> 这部分定义了对模板的配置<span class="token punctuation">,</span>和其他配置块不同<span class="token operator">.</span>这部分可以针对不同模板配置多次<span class="token operator">.</span>也可以在CLI命令<span class="token operator">/</span><span class="token operator">/</span> 直接进行配置template <span class="token punctuation">{</span>  <span class="token operator">/</span><span class="token operator">/</span> 这是输入模板的配置文件路径<span class="token punctuation">,</span>必选项  <span class="token keyword">source</span> <span class="token operator">=</span> <span class="token string">"/path/on/disk/to/template.ctmpl"</span>  <span class="token operator">/</span><span class="token operator">/</span> 这是源模板渲染之后存放的路径<span class="token punctuation">,</span>如果父目录不存在Consul Template会尝试进行创建  destination <span class="token operator">=</span> <span class="token string">"/path/on/disk/where/template/will/render.txt"</span>  <span class="token operator">/</span><span class="token operator">/</span> This <span class="token operator">is</span> the optional command <span class="token keyword">to</span> run when the template <span class="token operator">is</span> rendered<span class="token operator">.</span> The  <span class="token operator">/</span><span class="token operator">/</span> command will <span class="token keyword">only</span> run <span class="token keyword">if</span> the resulting template <span class="token keyword">changes</span><span class="token operator">.</span> The command must  <span class="token operator">/</span><span class="token operator">/</span> <span class="token keyword">return</span> within 30s <span class="token punctuation">(</span>configurable<span class="token punctuation">)</span><span class="token punctuation">,</span> and it must have a successful <span class="token keyword">exit</span> code<span class="token operator">.</span>  <span class="token operator">/</span><span class="token operator">/</span> Consul Template <span class="token operator">is</span> not a replacement <span class="token keyword">for</span> a process monitor or init system<span class="token operator">.</span>  <span class="token operator">/</span><span class="token operator">/</span> 这是当模板渲染完成后可选的要执行的命令<span class="token operator">.</span>这个命令只会在模板发生改变后才会运行<span class="token operator">.</span>这个命令必须要在<span class="token number">30</span>秒  <span class="token operator">/</span><span class="token operator">/</span> 内进行返回<span class="token punctuation">(</span>可配置<span class="token punctuation">)</span><span class="token punctuation">,</span>必须返回一个成功的退出码<span class="token operator">.</span>Consul Template不能替代进程监视或者init 系统  <span class="token operator">/</span><span class="token operator">/</span> 的功能  command <span class="token operator">=</span> <span class="token string">"restart service foo"</span>  <span class="token operator">/</span><span class="token operator">/</span> 这是最大的等待命令返回的时间<span class="token punctuation">,</span>默认是<span class="token number">30</span>秒  command_timeout <span class="token operator">=</span> <span class="token string">"60s"</span>  <span class="token operator">/</span><span class="token operator">/</span> 这是渲染后的文件的权限<span class="token punctuation">,</span>如果不设置<span class="token punctuation">,</span>Consul Template将去匹配之前已经存在的文件的权限<span class="token operator">.</span>  <span class="token operator">/</span><span class="token operator">/</span> 如果文件不存在<span class="token punctuation">,</span>权限会被设置为 <span class="token number">0644</span>  perms <span class="token operator">=</span> <span class="token number">0600</span>  <span class="token operator">/</span><span class="token operator">/</span> 这个选项对渲染之前的文件进行备份<span class="token operator">.</span>他保持一个备份<span class="token operator">.</span>  <span class="token operator">/</span><span class="token operator">/</span> 这个选项在发生意外更高时<span class="token punctuation">,</span>有一个回滚策略<span class="token operator">.</span>  <span class="token builtin">backup</span> <span class="token operator">=</span> true  <span class="token operator">/</span><span class="token operator">/</span> 模板的分隔符<span class="token punctuation">,</span>默认是 <span class="token string">"{{"</span>和<span class="token string">"}}"</span><span class="token operator">.</span>但是对于一些模板用其他的分隔符可能更好  <span class="token operator">/</span><span class="token operator">/</span> 可以避免与本身的冲突  left_delimiter  <span class="token operator">=</span> <span class="token string">"{{"</span>  right_delimiter <span class="token operator">=</span> <span class="token string">"}}"</span>  <span class="token operator">/</span><span class="token operator">/</span> 这是最小和最大等待渲染一个新模板和执行命令的时间<span class="token operator">.</span>使用 分号 个号<span class="token operator">.</span>如果忽略最大值<span class="token punctuation">,</span>最大  <span class="token operator">/</span><span class="token operator">/</span> 值会被设置为最小值的<span class="token number">4</span>倍<span class="token operator">.</span>这个选项没有默认值<span class="token operator">.</span>这个值相对全局所以的等待时间有最高优先级  wait <span class="token operator">=</span> <span class="token string">"2s:6s"</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注意: 不是所有的选项都是必选的.例如: 如果你没有使用Vault你不用设置这一块. 类似的你没有使用syslog系统你也不需要指定syslog配置.</p><p>为了更加安全,<code>token</code>也可以从环境变量里读取,使用 <code>CONSUL_TOKEN</code> 和 <code>VAULT_TOKEN</code>.强烈建议你不要把token放到未加密的文本配置文件中.</p><h3 id="模版语法"><a href="#模版语法" class="headerlink" title="模版语法"></a>模版语法</h3><p>Consul Template 使用了Go的模板语法.如果你对他的语法不熟悉建议你读下文档.他的语法看起来与 Mustache, Handlebars, 或者 Liquid 类似.</p><p>在Go 提供的模板函数之外,Consul Template暴露了以下的函数:</p><h3 id="API-函数"><a href="#API-函数" class="headerlink" title="API 函数"></a>API 函数</h3><h4 id="datacenters"><a href="#datacenters" class="headerlink" title="datacenters"></a>datacenters</h4><p>查询目录中的所有数据中心.使用以下语法:</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">{{datacenters}}<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="file"><a href="#file" class="headerlink" title="file"></a>file</h4><p>读取并输出磁盘上的本地文件,如果无法读取产生一个错误.使用如下语法</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">{{file "/path/to/local/file"}}<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这个例子将输出 <code>/path/to/local/file</code> 文件内容到模板. <strong>注意:这不会在嵌套模板中被处理</strong></p><h4 id="key"><a href="#key" class="headerlink" title="key"></a>key</h4><p>查询Consul指定key的值,如果key的值不能转换为字符串,将产生错误.使用如下语法:</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">{{key "service/redis/maxconns@east-aws"}}<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>上面的例子查询了在<code>east-aws</code>数据中心的 <code>service/redis/maxconns</code>的值.如果忽略数据中心参数,将会查询本地数据中心的值:</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">{{key "service/redis/maxconns"}}<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>Consul键值结构的美妙在于,这完全取决于你!</p><h4 id="key-or-default"><a href="#key-or-default" class="headerlink" title="key_or_default"></a>key_or_default</h4><p>查询Consul中指定的key的值,如果key不存在,则返回默认值.使用方式如下</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">{{key_or_default "service/redis/maxconns@east-aws" "5"}}<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>注意Consul Template使用了多个阶段的运算.在第一阶段的运算如果Consul没有返回值,则会一直使用默认值.后续模板解析中如果值存在了则会读取真实的值.这很重要,运维Consul Templae不会因为key_or_default没找到key而阻塞模板的的渲染.即使key存在如果Consul没有按时返回这个数据,也会使用默认值来进行替代.</p><h4 id="ls"><a href="#ls" class="headerlink" title="ls"></a>ls</h4><p>查看Consul的所有以指定前缀开头的<code>key-value</code>对.如果有值无法转换成字符串则会产生一个错误:</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">{{range ls "service/redis@east-aws"}}{{.Key}} {{.Value}}{{end}}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>如果Consul实例在<code>east-aws</code>数据中心存在这个结构<code>service/redis</code>,渲染后的模板应该类似这样:</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">minconns 2maxconns 12<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>如果你忽略数据中心属性,则会返回本地数据中心的查询结果.</p><h4 id="node"><a href="#node" class="headerlink" title="node"></a>node</h4><p>查询目录中的一个节点信息</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">{{node "node1"}}<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>如果未指定任何参数,则当前agent所在节点将会被返回:</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">{{node}}<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>你可以指定一个可选的参数来指定数据中心:</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">{{node "node1" "@east-aws"}}<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>如果指定的节点没有找到则会返回<code>nil</code>.如果节点存在就会列出节点的信息和节点提供的服务.</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">{{with node}}{{.Node.Node}} ({{.Node.Address}}){{range .Services}}  {{.Service}} {{.Port}} ({{.Tags | join ","}}){{end}}{{end}}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h4 id="nodes"><a href="#nodes" class="headerlink" title="nodes"></a>nodes</h4><p>查询目录中的全部节点,使用如下语法</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">{{nodes}}<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这个例子会查询Consul的默认数据中心.你可以使用可选参数指定一个可选参数来指定数据中心:</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">{{nodes "@east-aws"}}<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这个例子会查询<code>east-aws</code>数据中心的所有几点.</p><h4 id="secret"><a href="#secret" class="headerlink" title="secret"></a>secret</h4><p>查询<code>Vault</code>中指定路径的密匙.如果指定的路径不存在或者<code>Vault</code>的Token没有足够权限去读取指定的路径,将会产生一个错误.如果路径存在但是key不存在则返回.</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">{{with secret "secret/passwords"}}{{.Data.password}}{{end}}<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>可以使用如下字段:</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">LeaseID - the unique lease identifierLeaseDuration - the number of seconds the lease is validRenewable - if the secret is renewableData - the raw data - this is a map[string]interface{}, so it can be queried using Go's templating "dot notation"If the map key has dots "." in it, you need to access the value using the index function:{{index .Data "my.key.with.dots"}}If additional arguments are passed to the function, then the operation is assumed to be a write operation instead of a read operation. The write operation must return data in order to be valid. This is especially useful for the PKI secret backend, for example.{{ with secret "pki/issue/my-domain-dot-com" "common_name=foo.example.com" }}{{ .Data.certificate }}{{ end }}The parameters must be key=value pairs, and each pair must be its own argument to the function:{{ secret "path/" "a=b" "c=d" "e=f" }}Please always consider the security implications of having the contents of a secret in plain-text on disk. If an attacker is able to get access to the file, they will have access to plain-text secrets.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Please note that Vault does not support blocking queries. As a result, Consul Template will not immediately reload in the event a secret is changed as it does with Consul’s key-value store. Consul Template will fetch a new secret at half the lease duration of the original secret. For example, most items in Vault’s generic secret backend have a default 30 day lease. This means Consul Template will renew the secret every 15 days. As such, it is recommended that a smaller lease duration be used when generating the initial secret to force Consul Template to renew more often.</p><h4 id="secrets"><a href="#secrets" class="headerlink" title="secrets"></a>secrets</h4><p>Query Vault to list the secrets at the given path. Please note this requires Vault 0.5+ and the endpoint you want to list secrets must support listing. Not all endpoints support listing. The result is the list of secret names as strings.</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">{{range secrets "secret/"}}{{.}}{{end}}<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>The trailing slash is optional in the template, but the generated secret dependency will always have a trailing slash in log output.</p><p>To iterate and list over every secret in the generic secret backend in Vault, for example, you would need to do something like this:</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">{{range secrets "secret/"}}{{with secret (printf "secret/%s" .)}}{{range $k, $v := .Data}}{{$k}}: {{$v}}{{end}}{{end}}{{end}}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>You should probably never do this. Please also note that Vault does not support blocking queries. To understand the implications, please read the note at the end of the secret function.</p><h4 id="service"><a href="#service" class="headerlink" title="service"></a>service</h4><p>查询Consul中匹配表达式的服务.语法如下:</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">{{service "release.web@east-aws"}}<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>上面的例子查询Consul中,在<code>east-aws</code>数据中心存在的健康的 <code>web</code>服务.tag和数据中心参数是可选的.从当前数据中心查询所有节点的<code>web</code>服务而不管tag,查询语法如下:</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">{{service "web"}}<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这个函数返回<code>[]*HealthService</code>结构.可按照如下方式应用到模板:</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">{{range service "web@data center"}}server {{.Name}} {{.Address}}:{{.Port}}{{end}}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>产生如下输出:</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">server nyc_web_01 123.456.789.10:8080server nyc_web_02 456.789.101.213:8080<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>默认值会返回健康的服务,如果你想获取所有服务,可以增加any选项,如下:</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">{{service "web" "any"}}<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这样就会返回注册过的所有服务,而不论他的状态如何.</p><p>如果你想过滤指定的一个或者多个健康状态,你可以通过逗号隔开多个健康状态:</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">{{service "web" "passing, warning"}}<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这样将会返回被他们的节点和服务级别的检查定义标记为 “passing” 或者 “warning”的服务. 请注意逗号是 OR而不是AND的意思.</p><p>指定了超过一个状态过滤,并包含<code>any</code>将会返回一个错误.因为<code>any</code>是比所有状态更高级的过滤.</p><p>后面这2种方式有些架构上的不同:</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">{{service "web"}}{{service "web" "passing"}}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>前者会返回Consul认为<code>healthy</code>和<code>passing</code>的所有服务.后者将返回所有已经在Consul注册的服务.然后会执行一个客户端的过滤.通常如果你想获取健康的服务,你应该不要使用<code>passing</code>参数,直接忽略第三个参数即可.然而第三个参数在你想查询 <code>passing</code>或者<code>warning</code>的服务会比较有用,如下:</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">{{service "web" "passing, warning"}}<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>服务的状态也是可见的,如果你想自己做一些额外的过滤,语法如下:</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">{{range service "web" "any"}}{{if eq .Status "critical"}}// Critical state!{{end}}{{if eq .Status "passing"}}// Ok{{end}}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>执行命令时,在Consul将服务设置为维护模式,只需要在你的命令上包上Consul的 maint 调用:</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">#!/bin/shset -econsul maint -enable -service web -reason "Consul Template updated"service nginx reloadconsul maint -disable -service web<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>另外如果你没有安装Consul agent,你可以直接调用API请求:</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">#!/bin/shset -ecurl -X PUT "http://$CONSUL_HTTP_ADDR/v1/agent/service/maintenance/web?enable=true&amp;reason=Consul+Template+Updated"service nginx reloadcurl -X PUT "http://$CONSUL_HTTP_ADDR/v1/agent/service/maintenance/web?enable=false"<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="services"><a href="#services" class="headerlink" title="services"></a>services</h4><p>查询Consul目录中的所有服务,使用如下语法:</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">{{services}}<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这个例子将查询Consul的默认数据中心,你可以指定一个可选参数来指定数据中心:</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">{{services "@east-aws"}}<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>请注意: <code>services</code>函数与<code>service</code>是不同的,<code>service</code>接受更多参数并且查询监控的服务列表.这个查询Consul目录并返回一个服务的tag的Map,如下:</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">{{range services}}{{.Name}}{{range .Tags}}  {{.}}{{end}}{{end}}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="tree"><a href="#tree" class="headerlink" title="tree"></a>tree</h4><p>查询所有指定前缀的key-value值对,如果其中的值有无法转换为字符串的则引发错误:</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">{{range tree "service/redis@east-aws"}}{{.Key}} {{.Value}}{{end}}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>如果Consul实例在<code>east-aws</code>数据中心有一个<code>service/redis</code>结构,模板的渲染结果类似下面:</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">minconns 2maxconns 12nested/config/value "value"<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>和<code>ls</code>不同,<code>tree</code>返回前缀下的所有key.和Unix的tree命令比较像.如果忽略数据中心参数,则会使用本地数据中心</p><p><a href="https://book-consul-guide.vnzmi.com/11_consul_template.html">查看更多</a></p><p><a href="https://book-consul-guide.vnzmi.com/11_consul_template.html">项目Github地址</a></p><h3 id="Haproxy-实例"><a href="#Haproxy-实例" class="headerlink" title="Haproxy 实例"></a>Haproxy 实例</h3><p>根据haproxy服务的配置文件创建一个consul-template模版渲染文件: <code>haproxy.ctmpl</code></p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"># Consul Haproxy configuredglobal        maxconn         20480        ulimit-n        65535        log             127.0.0.1 local5        uid             200        gid             200        chroot          /usr/local/haproxy        nbproc          1        daemon        pidfile         /usr/local/haproxy/logs/haproxy.piddefaults        log             global        mode            http        option          httplog        option          dontlognull        option          forwardfor        option          abortonclose        retries         3        maxconn         3000        stats           enable        stats           hide-version        stats   uri     /admin        stats   auth    admin:admin        stats   refresh 10s        balance         roundrobin        timeout connect 5000ms        timeout client 50000ms        timeout server 50000ms        timeout check 2000mslisten web_haproxy        bind 0.0.0.0:8080        mode http        log     127.0.0.1 local5 err        stats   refresh 5s        stats   uri /admin        stats   realm liang lian        stats   auth admin:admin        stats   hide-version        stats   admin if TRUEfrontend consul        bind    0.0.0.0:8500        mode    http        log     global        default_backend consul-clusterbackend consul-cluster        mode http        {{range service "Faceid"}}        server {{.ID}} {{.Address}}:{{.Port}} check inter 5000 fall 1 rise 2 weight 2{{end}}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>运行consul-template作为一个服务,通过上面的渲染模版渲染一个haproxy.cfg的配置文件, 然后重启haproxy服务</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">consul-template -consul-addr=10.201.102.185:8500 -template "/root/haproxy.ctmpl:/etc/haproxy.cfg:service haproxy restart"10.201.102.185 是consul集群的VIP, 为了避免单独调某一台服务器服务器出现故障后consul-template无法工作. <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>渲染后的<code>haproxy.cfg</code></p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"># Consul Haproxy configuredglobal        maxconn         20480        ulimit-n        65535        log             127.0.0.1 local5        uid             200        gid             200        chroot          /usr/local/haproxy        nbproc          1        daemon        pidfile         /usr/local/haproxy/logs/haproxy.piddefaults        log             global        mode            http        option          httplog        option          dontlognull        option          forwardfor        option          abortonclose        retries         3        maxconn         3000        stats           enable        stats           hide-version        stats   uri     /admin        stats   auth    admin:admin        stats   refresh 10s        balance         roundrobin        timeout connect 5000ms        timeout client 50000ms        timeout server 50000ms        timeout check 2000mslisten web_haproxy        bind 0.0.0.0:8080        mode http        log     127.0.0.1 local5 err        stats   refresh 5s        stats   uri /admin        stats   realm liang lian        stats   auth admin:admin        stats   hide-version        stats   admin if TRUEfrontend consul        bind    0.0.0.0:8500        mode    http        log     global        default_backend consul-clusterbackend consul-cluster        mode http        server Faceid 10.201.102.198:9000 check inter 5000 fall 1 rise 2 weight 2        server Faceid 10.201.102.199:9000 check inter 5000 fall 1 rise 2 weight 2        server Faceid 10.201.102.200:9000 check inter 5000 fall 1 rise 2 weight 2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>整个就是搭建consul集群, 平台中的服务会注册到consul集群中, haproxy避免consul-template调consul时出现单点故障consul-template无法工作做的高可用, Consul-template就是能在整个平台的各个系统和应用中使用, 查询consul集群来获取平台上各个应用的存活状态和IP. </p><p>整套下来实现了两个重点: </p><ul><li>实现了中心服务注册查询</li><li>平台中其他节点的查询服务和配置文件自动更新</li></ul>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 开源软件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Consul </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LVM学习笔记</title>
      <link href="2021/06/15/lvm-xue-xi-bi-ji/"/>
      <url>2021/06/15/lvm-xue-xi-bi-ji/</url>
      
        <content type="html"><![CDATA[<p><strong>写在前面：</strong><br>今天开会讨论了 PH2 相关服务器的部署问题，发现老外创建的系统没有使用 LVM，这对之后的运维工作制造了不必要的麻烦。以前没有详尽的了解过 LVM。正好借着这个机会了解下~</p><h2 id="关于-LVM"><a href="#关于-LVM" class="headerlink" title="关于 LVM"></a>关于 LVM</h2><h3 id="概念解释"><a href="#概念解释" class="headerlink" title="概念解释"></a>概念解释</h3><p>LVM(Logical Volume Manager)逻辑卷管理，是一种将一个或多个硬盘的分区在逻辑上集合，相当于一个大硬盘来使用，当硬盘的空间不够使用的时候，可以继续将其它的硬盘分区加入其中，这样可以实现一种磁盘空间的动态管理，相对于普通的磁盘分区有很大的灵活性，使用普通的磁盘分区，当一个磁盘的分区空间不够使用的时候，很可能带来很大的麻烦。使用 LVM 在一定程度上就可以解决普通磁盘分区带来的问题。</p><h3 id="为什么使用-LVM"><a href="#为什么使用-LVM" class="headerlink" title="为什么使用 LVM"></a>为什么使用 LVM</h3><p>LVM 通常用于装备大量磁盘的系统, 比如服务器中的磁盘阵列。<br>但 LVM 同样适用于仅有一、两块硬盘的小系统。</p><h4 id="小系统使用LVM的益处"><a href="#小系统使用LVM的益处" class="headerlink" title="小系统使用LVM的益处"></a>小系统使用LVM的益处</h4><p><strong>传统的文件系统</strong></p><p>一个文件系统对应一个分区，直观，但不易改变，不同的分区相对独立，无相互联系，各分区空间常常利用不平衡，空间不能充分利用。当一个文件系统／分区已满时，无法对其扩充，只能采用重新分区／建立文件系统，非常麻烦，或把分区中的数据移到另一个更大的分区中；或采用符号连接的方式使用其它分区的空间。如果要把硬盘上的多个分区合并在一起使用，只能采用再分区的方式，这个过程需要数据的备份与恢复。</p><p><strong>采用LVM</strong></p><p>硬盘的多个分区由LVM统一为卷组管理，可以方便的加入或移走分区以扩大或减小卷组的可用容量，充分利用硬盘空间；文件系统建立在逻辑卷上，而逻辑卷可根据需要改变大小(在卷组容量范围内)以满足要求，可以跨分区。</p><h4 id="大系统使用LVM的益处"><a href="#大系统使用LVM的益处" class="headerlink" title="大系统使用LVM的益处"></a>大系统使用LVM的益处</h4><p>在使用很多硬盘的大系统中，使用LVM主要是方便管理、增加了系统的扩展性。用户／用户组的空间建立在LVM上，可以随时按要求增大，或根据使用情况对各逻辑卷进行调整。当系统空间不足而加入新的硬盘时，不必把用户的数据从原硬盘迁移到新硬盘，而只须把新的分区加入卷组并扩充逻辑卷即可。同样，使用LVM可以在不停服务的情况下。把用户数据从旧硬盘转移到新硬盘空间中去。</p><h2 id="LVM原理"><a href="#LVM原理" class="headerlink" title="LVM原理"></a>LVM原理</h2><p>传统文件系统，比如这个盘只有300G，那么建立在这个300G上面的文件系统最多只能用到300G，但是有了LVM这个功能后，我们建立文件系统的盘就不是建立在物理盘上，而是建立在一个叫LV逻辑卷上面，这个卷是一个逻辑概念不是物理盘，空间可能大于一个物理盘，也可能小于一个物理盘。而且这个LV逻辑卷的空间可以扩展和缩小，这样就给上层的文件系统提供了更好的支持。</p><h3 id="名词解释"><a href="#名词解释" class="headerlink" title="名词解释"></a>名词解释</h3><p><strong>PV(Physical Volume):</strong> 物理卷, 处于 LVM 最底层, 其实就是指一个分区（如/dev/sdb1 ）或者是一个盘（如/dev/sdb）。</p><p><strong>VG(Volume Group):</strong> 卷组, 建立在 PV 之上, 可以含有一个到多个 PV。（相当于一个Pool，由多个PV组成的pool）</p><p><strong>LV(Logical Volume):</strong> 逻辑卷, 建立在 VG 之上, 相当于原来分区的概念, 不过大小可以动态改变。(比如/dev/mapper/rhel-root这个目录其实是一个文件系统挂载点，这个点就是承载在一个LV上，这个文件系统的大小就是这个LV的大小。)</p><h3 id="原理图"><a href="#原理图" class="headerlink" title="原理图"></a>原理图</h3><p><img src="/images/lvm.png" alt="LVM原理图"></p><h2 id="普通的挂载磁盘方法"><a href="#普通的挂载磁盘方法" class="headerlink" title="普通的挂载磁盘方法"></a>普通的挂载磁盘方法</h2><h3 id="创建分区的主要操作"><a href="#创建分区的主要操作" class="headerlink" title="创建分区的主要操作"></a>创建分区的主要操作</h3><h4 id="查看分区情况：-fdisk-l"><a href="#查看分区情况：-fdisk-l" class="headerlink" title="查看分区情况： fdisk -l"></a>查看分区情况： fdisk -l</h4><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"> fdisk -lDisk /dev/sda: 299.0 GB, 298999349248 bytes# 磁盘/dev/sda255 heads, 63 sectors/track, 36351 cylindersUnits = cylinders of 16065 * 512 = 8225280 bytesSector size (logical/physical): 512 bytes / 512 bytesI/O size (minimum/optimal): 512 bytes / 512 bytesDisk identifier: 0x4d69fe0e   Device Boot      Start         End      Blocks   Id  System/dev/sda1   *           1          26      204800   83  Linux# 分为2个区, sda1Partition 1 does not end on cylinder boundary./dev/sda2              26       36352   291785728   8e  Linux LVM# sda2# 磁盘/dev/sdb没有分区Disk /dev/sdb: 4000.0 GB, 3999999721472 bytes255 heads, 63 sectors/track, 486305 cylindersUnits = cylinders of 16065 * 512 = 8225280 bytesSector size (logical/physical): 512 bytes / 512 bytesI/O size (minimum/optimal): 512 bytes / 512 bytesDisk identifier: 0x00000000......<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="查看已有磁盘：-lsblk"><a href="#查看已有磁盘：-lsblk" class="headerlink" title="查看已有磁盘： lsblk"></a>查看已有磁盘： lsblk</h4><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"> lsblkNAME                       MAJ:MIN RM   SIZE RO TYPE MOUNTPOINTsda                          8:0    0 278.5G  0 disk├─sda1                       8:1    0   200M  0 part /boot└─sda2                       8:2    0 278.3G  0 part  └─VolGroup-LogVol (dm-0) 253:0    0   1.9T  0 lvm  /# LVM类型的分区sdb                          8:32   0   3.7T  0 disk # 还没有分区的新磁盘<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="对新磁盘进行分区：-fdisk-dev-sdb"><a href="#对新磁盘进行分区：-fdisk-dev-sdb" class="headerlink" title="对新磁盘进行分区： fdisk /dev/sdb"></a>对新磁盘进行分区： fdisk /dev/sdb</h4><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"> fdisk /dev/sdbDevice contains neither a valid DOS partition table, nor Sun, SGI or OSF disklabelBuilding a new DOS disklabel with disk identifier 0xf91f8c4c.Changes will remain in memory only, until you decide to write them.After that, of course, the previous content won't be recoverable.Warning: invalid flag 0x0000 of partition table 4 will be corrected by w(rite)WARNING: The size of this disk is 4.0 TB (4000225165312 bytes).DOS partition table format can not be used on drives for volumeslarger than (2199023255040 bytes) for 512-byte sectors. Use parted(1) and GUIDpartition table format (GPT).WARNING: DOS-compatible mode is deprecated. It's strongly recommended to         switch off the mode (command 'c') and change display units to         sectors (command 'u').Command (m for help): n# n 表示新建分区Command action   e   extended   p   primary partition (1-4)p# p 表示分区类型为主分区, 主分区只有1-4种选择Partition number (1-4): 1# 主分区的编号First cylinder (1-486333, default 1): # 开始扇区号, 直接回车, 使用默认值1Using default value 1# 结束扇区号, 使用默认值 --- 这里只加载了新磁盘的一半(2T), 所以还需要再次创建分区/dev/sdb2使用剩下的一半.Last cylinder, +cylinders or +size{K,M,G} (1-267349, default 267349):Using default value 267349Command (m for help):  w#  将上述设置写入分区表并退出The partition table has been altered!Calling ioctl() to re-read partition table.Syncing disks.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="再次查看分区情况-fdisk-l"><a href="#再次查看分区情况-fdisk-l" class="headerlink" title="再次查看分区情况 - fdisk -l"></a>再次查看分区情况 - fdisk -l</h4><p>多出来一个/dev/sdb1 的区, 这个 1 就是之前主分区之后指定的分区编号.</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"> fdisk -lDisk /dev/sda: 299.0 GB, 298999349248 bytes255 heads, 63 sectors/track, 36351 cylindersUnits = cylinders of 16065 * 512 = 8225280 bytesSector size (logical/physical): 512 bytes / 512 bytesI/O size (minimum/optimal): 512 bytes / 512 bytesDisk identifier: 0x4d69fe0e   Device Boot      Start         End      Blocks   Id  System/dev/sda1   *           1          26      204800   83  LinuxPartition 1 does not end on cylinder boundary./dev/sda2              26       36352   291785728   8e  Linux LVM# /dev/sdb磁盘:Disk /dev/sdb: 4000.0 GB, 3999999721472 bytes255 heads, 63 sectors/track, 486305 cylindersUnits = cylinders of 16065 * 512 = 8225280 bytesSector size (logical/physical): 512 bytes / 512 bytesI/O size (minimum/optimal): 512 bytes / 512 bytesDisk identifier: 0x8f3043b5# 多出来的分区/dev/sdb1   Device Boot      Start         End      Blocks   Id  System/dev/sdb1               1      267349  2147480811   83  Linux......<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="查看当前分区表中的分区信息：-cat-proc-partitions"><a href="#查看当前分区表中的分区信息：-cat-proc-partitions" class="headerlink" title="查看当前分区表中的分区信息： cat /proc/partitions"></a>查看当前分区表中的分区信息： cat /proc/partitions</h4><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"> cat /proc/partitionsmajor minor  #blocks  name   8        0   291991552  sda   8        1      204800  sda1   8        2   291785728  sda2   8       32  3906249728  sdb# 添加的新磁盘   8       33  2147480811  sdb1# 创建的新分区 253        0  2046660608  dm-0如果创建完之后，cat /proc/partitions 查看不到对应的分区，使用 parprobe 刷新命令即可: partprobe /dev/sdc<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="格式化新分区"><a href="#格式化新分区" class="headerlink" title="格式化新分区"></a>格式化新分区</h3><h4 id="格式化新分区-mkfs-t"><a href="#格式化新分区-mkfs-t" class="headerlink" title="格式化新分区: mkfs -t"></a>格式化新分区: mkfs -t</h4><p>这里建议将新分区格式化为 ext4 文件类型，还有 ext2，ext3 等文件类型，区别请参考博客 ext2、ext3 与 ext4 的区别。</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"> mkfs -t ext4 /dev/sdb1mke2fs 1.41.12 (17-May-2010)Filesystem label=OS type: LinuxBlock size=4096 (log=2)Fragment size=4096 (log=2)Stride=0 blocks, Stripe width=0 blocks134217728 inodes, 536870202 blocks26843510 blocks (5.00%) reserved for the super userFirst data block=0Maximum filesystem blocks=429496729616384 block groups32768 blocks per group, 32768 fragments per group8192 inodes per groupSuperblock backups stored on blocks:        32768, 98304, 163840, 229376, 294912, 819200, 884736, 1605632, 2654208,        4096000, 7962624, 11239424, 20480000, 23887872, 71663616, 78675968,        102400000, 214990848, 512000000Writing inode tables:  8874/16384<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>等待一小会后, 将出现下述提示, 说明格式化完成:</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">Writing inode tables: doneCreating journal (32768 blocks): doneWriting superblocks and filesystem accounting information:  doneThis filesystem will be automatically checked every 26 mounts or180 days, whichever comes first.  Use tune2fs -c or -i to override.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="挂载新分区"><a href="#挂载新分区" class="headerlink" title="挂载新分区"></a>挂载新分区</h3><h4 id="创建目录-并将-dev-sdb1-挂在到该目录下"><a href="#创建目录-并将-dev-sdb1-挂在到该目录下" class="headerlink" title="创建目录, 并将 /dev/sdb1 挂在到该目录下:"></a>创建目录, 并将 /dev/sdb1 挂在到该目录下:</h4><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">[root@localhost /]# mkdir data &amp;&amp; cd /data[root@localhost data]# mount /dev/sdc1 /data<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="查看挂载是否成功"><a href="#查看挂载是否成功" class="headerlink" title="查看挂载是否成功:"></a>查看挂载是否成功:</h4><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">[root@localhost data]# df -lFilesystem                   1K-blocks       Used  Available Use% Mounted on/dev/mapper/VolGroup-LogVol  286901696   18601728  253726196   7% /tmpfs                         66020980          0   66020980   0% /dev/shm/dev/sda1                       495844      33476     436768   8% /boot# 挂载成功:/dev/sdb1                   2113784984     202776 2006208168   1% /data<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="设置开机自动挂载"><a href="#设置开机自动挂载" class="headerlink" title="设置开机自动挂载"></a>设置开机自动挂载</h3><p>编辑文件 /etc/fstab</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">[root@localhost data]# vim /etc/fstab# 文件内容如下:# /etc/fstab# Created by anaconda on Wed Sep 12 10:41:40 2018## Accessible filesystems, by reference, are maintained under '/dev/disk'# See man pages fstab(5), findfs(8), mount(8) and/or blkid(8) for more info#/dev/mapper/VolGroup-LogVol  /                     ext4    defaults        1 1/dev/sdb1                    /data                 ext4    defaults        1 1UUID=22b1d425-d050-43c3-a735-06d48bbb9051 /boot    ext4    defaults        1 2tmpfs                        /dev/shm              tmpfs   defaults        0 0devpts                       /dev/pts              devpts  gid=5,mode=620  0 0sysfs                        /sys                  sysfs   defaults        0 0proc                         /proc                 proc    defaults        0 0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="LVM-方式挂载磁盘-推荐"><a href="#LVM-方式挂载磁盘-推荐" class="headerlink" title="LVM 方式挂载磁盘(推荐)"></a>LVM 方式挂载磁盘(推荐)</h2><h3 id="创建PV，VG，LV的指令"><a href="#创建PV，VG，LV的指令" class="headerlink" title="创建PV，VG，LV的指令"></a>创建PV，VG，LV的指令</h3><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">创建物理卷pvcreate /dev/vdb1            ##创建物理卷/dev/vdb1创建物理卷组vgcreate vg0 /dev/vdb1        ##创建物理卷组vg0创建逻辑卷lvcreate -L 300M -n lv0 vg0   ##在vg0卷组上创建名为lv0，大小为300M的逻辑卷<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="创建一个逻辑卷（操作展示）"><a href="#创建一个逻辑卷（操作展示）" class="headerlink" title="创建一个逻辑卷（操作展示）"></a>创建一个逻辑卷（操作展示）</h3><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">fdisk /dev/vda<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/images/change_disk_type.png" alt="更改分区类型"></p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">pvcreate /dev/vdb1            #创建物理卷vgcreate -s 8M vg0 /dev/vdb1  #创建物理卷组vg0,PE为8Mlvcreate -L 300M -n lv0 vg0   #在卷组vg0上创建名为lv0，大小为300M的逻辑卷mkfs.xfs /dev/vg0/lv0         #格式化逻辑卷并改系统格式为xfsmount /dev/vg0/lv0 /mnt       #挂载(linux下的文件系统需要被挂载后才能使用)df -h<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="扩容"><a href="#扩容" class="headerlink" title="扩容"></a>扩容</h3><h4 id="xfs系统中的扩容："><a href="#xfs系统中的扩容：" class="headerlink" title="xfs系统中的扩容："></a>xfs系统中的扩容：</h4><p><strong>情况一：vg足够扩展</strong></p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">lvextend -L 500M /dev/vg0/lv0      ##扩展逻辑卷空间到500Mxfs_growfs /dev/vg0/lv0            ##扩展文件系统<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong>情况二：vg不够拉伸，得先扩大设备再扩大系统</strong></p><p>扩大设备</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">pvcreate /dev/vdb2        ##创建物理卷/dev/vdb2 vgextend vg0 /dev/vdb2    ##将新的物理卷vdb2添加到现有的卷组vg0 <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>扩展逻辑卷</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">lvextend -L 1500M /dev/vg0/lv0     ##增加逻辑卷空间到1500M xfs_growfs /dev/vg0/lv0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="ext4系统的扩容"><a href="#ext4系统的扩容" class="headerlink" title="ext4系统的扩容"></a>ext4系统的扩容</h3><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">umount /mnt              ##先卸载 mkfs.ext4 /dev/vg0/lv0   ##格式化逻辑卷 ，并改系统为ext4mount /dev/vg0/lv0 /mnt/ ##挂载 lvextend -L 1800M /dev/vg0/lv0  ##增加逻辑卷空间 Extending logical volume lv0 to 1.76 GiB Logical volume lv0 successfully resized resize2fs /dev/vg0/lv0   ##更新逻辑卷信息<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="缩减逻辑卷空间"><a href="#缩减逻辑卷空间" class="headerlink" title="缩减逻辑卷空间"></a>缩减逻辑卷空间</h3><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">umount /mnt                     ##先卸载e2fsck -f /dev/vg0/lv0          ##扫描逻辑卷上的空余空间resize2fs /dev/vg0/lv0 1000M    ##设备文件减少到1000Mlvreduce -L 1000M /dev/vg0/lv0  ##将逻辑卷减少到1000Mmount /dev/vg0/lv0 /mnt         ##挂载<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="缩减vg：（迁移到闲置设备）"><a href="#缩减vg：（迁移到闲置设备）" class="headerlink" title="缩减vg：（迁移到闲置设备）"></a>缩减vg：（迁移到闲置设备）</h3><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">pvmove /dev/vdb1 /dev/vdb2  ##将vdb1的空间数据转移到vdb2  /dev/vdb1: Moved: 88.0%  /dev/vdb1: Moved: 100.0%  ##转移数据成功vgreduce vg0 /dev/vdb1      ##将/dev/vdb1分区从vg0卷组中移除  Removed "/dev/vdb1" from volume group "vg0"pvremove /dev/vdb1          ##把/dev/vdb1分区从系统中删除  Labels on physical volume "/dev/vdb1" successfully wiped<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>注意：将vdb1的空间数据转移到vdb2时，要确保vdb2的足够的空间能将vdb1的数据转移，否则需要先将vdb1缩减。</p></blockquote><h3 id="LVM快照创建"><a href="#LVM快照创建" class="headerlink" title="LVM快照创建"></a>LVM快照创建</h3><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">touch /mnt/file{1..5}lvcreate -L 50M -n lv0backup -s /dev/vg0/lv0  ##建立一个50M的快照mount /dev/vg0/lv0backup /mnt                 ##挂载快照cd /mntlsrm -fr *                                   ##删除所有文件cdumount /mntlvremove /dev/vg0/lv0backup                   ##删除快照lvcreate -L 50M -n lv0backup -s /dev/vg0/lv0  ##重建快照mount /dev/vg0/lv0backup /mnt                 ##挂载快照ls /mnt                                ##又可以看到之前建立的文件<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>结论： LVM的快照可以将某一时刻的信息记录到快照区中，因此，可以利用这一特点对数据做完全备份。</p><h3 id="删除设备"><a href="#删除设备" class="headerlink" title="删除设备"></a>删除设备</h3><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">umount /mnt  ##卸载df -hlvremove /dev/vg0/lv0backup    ##删除快照lvremove /dev/vg0/lv0         ##删除逻辑卷vgremove vg0                  ##删除物理卷组pvremove /dev/vdb{1..2}       ##删除物理卷<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Helm3使用笔记</title>
      <link href="2021/06/10/helm3-shi-yong-bi-ji/"/>
      <url>2021/06/10/helm3-shi-yong-bi-ji/</url>
      
        <content type="html"><![CDATA[<h2 id="关于-Helm"><a href="#关于-Helm" class="headerlink" title="关于 Helm"></a>关于 Helm</h2><h3 id="什么是-Helm？"><a href="#什么是-Helm？" class="headerlink" title="什么是 Helm？"></a>什么是 Helm？</h3><p>Helm 是一个简化安装和管理 Kubernetes 应用程序的工具，可以将其视为 Kubernetes 的 <code>apt/yum/homebrew</code><br>Helm 是用于管理 Charts 的工具，Charts 是预先配置的 Kubernetes 资源的软件包。<br>官网：<a href="https://helm.sh/">https://helm.sh</a></p><h3 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h3><ol><li>查找并使用 Helm Charts 将应用程序部署在 Kubernetes 上</li><li>通过 Helm Charts 将应用程序共享</li><li>对 Kubernetes 应用程序实现可重复构建</li><li>简便管理 Kubernetes 清单文件</li><li>管理 Helm 包的发布</li></ol><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>Chart： Helm 应用(package)，包括对资源的定义及相关镜像的引用，还有模板文件、Values 文件等<br>Repository： Chart 仓库，http/https 服务器，Chart 的程序包放在这里<br>Release： Chart 的部署实例，每个 Chart 可以部署一个或多个 Release</p><h3 id="版本"><a href="#版本" class="headerlink" title="版本"></a>版本</h3><ul><li><p>在 Helm 2 中，Tiller 是作为一个 Deployment 部署在 kube-system 命名空间中，很多情况下，我们会为 Tiller 准备一个 ServiceAccount ，这个 ServiceAccount 通常拥有集群的所有权限。<br>用户可以使用本地 Helm 命令，自由地连接到 Tiller 中并通过 Tiller 创建、修改、删除任意命名空间下的任意资源。</p></li><li><p>在 Helm 3 中，Tiller 被移除了。新的 Helm 客户端会像 kubectl 命令一样，读取本地的 kubeconfig 文件，使用我们在 kubeconfig 中预先定义好的权限来进行一系列操作。</p></li></ul><h2 id="Helm-安装"><a href="#Helm-安装" class="headerlink" title="Helm 安装"></a>Helm 安装</h2><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"># tar包安装mkdir /software cd /softwarewget https://get.helm.sh/helm-v3.3.0-linux-amd64.tar.gztar xf helm-v3.3.0-linux-amd64.tar.gzcp linux-amd64/helm /usr/local/bin/helm# 脚本安装curl https://raw.githubusercontent.com/helm/helm/master/scripts/get-helm-3 | bash# 源码安装git clone https://github.com/helm/helm.gitcd helm &amp;&amp; make# 命令补全插件apt install bash-completion -ysource /usr/share/bash-completion/bash_completionecho "source &lt;(helm completion bash)" &gt;&gt; ~/.bash_profilesource !$<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="查看版本"><a href="#查看版本" class="headerlink" title="查看版本"></a>查看版本</h3><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">helm versionversion.BuildInfo{Version:"v3.5.4", GitCommit:"1b5edb69df3d3a08df77c9902dc17af864ff05d1", GitTreeState:"clean", GoVersion:"go1.15.11"}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="Helm-使用"><a href="#Helm-使用" class="headerlink" title="Helm 使用"></a>Helm 使用</h2><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">completion       生成自动补全脚本create           创建一个给定名称的chartdependency       管理chart的依赖关系env              helm环境信息get              获取给定release的扩展信息help             命令帮助history          获取release历史install          部署chartlint             对chart进行语法检查list             releases列表，list可简写为lspackage          打包chartplugin           install、list、uninstall Helm插件pull             从repo中下载chart并（可选）将其解压到本地目录repo             add、list、remove、update、index Helm的reporollback         回滚release到一个以前的版本search           查询在charts中的关键字show             显示chart的信息status           显示给定release的状态template         本地渲染模板test             测试运行releaseuninstall        删除releaseupgrade          升级releaseverify           验证给定路径的chart是否已签名且有效version          显示helm的版本信息<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="添加-Repo-源"><a href="#添加-Repo-源" class="headerlink" title="添加 Repo 源"></a>添加 Repo 源</h3><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">helm repo add stable http://mirror.azure.cn/kubernetes/chartshelm repo add aliyun https://kubernetes.oss-cn-hangzhou.aliyuncs.com/chartshelm repo add incubator https://kubernetes-charts-incubator.storage.googleapis.comhelm repo listhelm repo updatehelm search repo stable                                 #查询stable repo可用的chartshelm repo remove incubator                              #删除incubator repo<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="查看-Chart-信息"><a href="#查看-Chart-信息" class="headerlink" title="查看 Chart 信息"></a>查看 Chart 信息</h3><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">helm show chart stable/mysqlhelm show all stable/mysql<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="安装-Chart"><a href="#安装-Chart" class="headerlink" title="安装 Chart"></a>安装 Chart</h3><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">helm install redis stable/redis -n default              #部署chart到k8shelm ls                                                 #查看所有releaseNAME NAMESPACEREVISIONUPDATED                                STATUS  CHART       APP VERSIONredisdefault  1       2020-08-18 15:37:32.388925542 +0800 CSTdeployedredis-10.5.75.0.7helm status redis                                       #查看release状态helm uninstall redis                                    #删除release<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h3><p>Charts 除了可以在 repo 中下载，还可以自己自定义，创建完成后通过 helm 部署到 k8s。</p><h4 id="拉取"><a href="#拉取" class="headerlink" title="拉取"></a>拉取</h4><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">helm pull stable/mysqlls  mysql-1.6.6.tgztar xf mysql-1.6.6.tgztree mysql  mysql  ├── Chart.yaml  ├── README.md  ├── templates  │   ├── configurationFiles-configmap.yaml  │   ├── deployment.yaml  │   ├── _helpers.tpl  │   ├── initializationFiles-configmap.yaml  │   ├── NOTES.txt  │   ├── pvc.yaml  │   ├── secrets.yaml  │   ├── serviceaccount.yaml  │   ├── servicemonitor.yaml  │   ├── svc.yaml  │   └── tests  │       ├── test-configmap.yaml  │       └── test.yaml  └── values.yaml  2 directories, 15 files<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看到，一个 chart 包就是一个文件夹的集合，文件夹名称就是 chart 包的名称。<br>chart 是包含至少两项内容的 helm 软件包：<br>一个或多个模板，其中包含 Kubernetes 清单文件：</p><ul><li>NOTES.txt: chart 的“帮助文本”，在用户运行 helm install 时显示给用户</li><li>deployment.yaml: 创建 deployment 的基本 manifest</li><li>service.yaml: 为 deployment 创建 service 的基本 manifest</li><li>ingress.yaml: 创建 ingress 对象的资源清单文件</li><li>_helpers.tpl: 放置模板助手的地方，可以在整个 chart 中重复使用</li></ul><h4 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h4><p>以 nginx 为例，创建自定义的 chart。</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">helm create nginxtree nginx  nginx  ├── charts  ├── Chart.yaml  ├── templates  │   ├── deployment.yaml  │   ├── _helpers.tpl  │   ├── hpa.yaml  │   ├── ingress.yaml  │   ├── NOTES.txt  │   ├── serviceaccount.yaml  │   ├── service.yaml  │   └── tests  │       └── test-connection.yaml  └── values.yaml  3 directories, 10 files<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">cat nginx/templates/deployment.yaml<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> apps/v1<span class="token key atrule">kind</span><span class="token punctuation">:</span> Deployment<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">name</span><span class="token punctuation">:</span> <span class="token punctuation">{</span><span class="token punctuation">{</span> include "nginx.fullname" . <span class="token punctuation">}</span><span class="token punctuation">}</span>  <span class="token key atrule">labels</span><span class="token punctuation">:</span>    <span class="token punctuation">{</span><span class="token punctuation">{</span><span class="token punctuation">-</span> include "nginx.labels" . <span class="token punctuation">|</span> nindent 4 <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token key atrule">spec</span><span class="token punctuation">:</span><span class="token punctuation">{</span><span class="token punctuation">{</span><span class="token punctuation">-</span> if not .Values.autoscaling.enabled <span class="token punctuation">}</span><span class="token punctuation">}</span>  <span class="token key atrule">replicas</span><span class="token punctuation">:</span> <span class="token punctuation">{</span><span class="token punctuation">{</span> .Values.replicaCount <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">{</span><span class="token punctuation">{</span><span class="token punctuation">-</span> end <span class="token punctuation">}</span><span class="token punctuation">}</span>  <span class="token key atrule">selector</span><span class="token punctuation">:</span>    <span class="token key atrule">matchLabels</span><span class="token punctuation">:</span>      <span class="token punctuation">{</span><span class="token punctuation">{</span><span class="token punctuation">-</span> include "nginx.selectorLabels" . <span class="token punctuation">|</span> nindent 6 <span class="token punctuation">}</span><span class="token punctuation">}</span>  <span class="token key atrule">template</span><span class="token punctuation">:</span>    <span class="token key atrule">metadata</span><span class="token punctuation">:</span>    <span class="token punctuation">{</span><span class="token punctuation">{</span><span class="token punctuation">-</span> with .Values.podAnnotations <span class="token punctuation">}</span><span class="token punctuation">}</span>      <span class="token key atrule">annotations</span><span class="token punctuation">:</span>        <span class="token punctuation">{</span><span class="token punctuation">{</span><span class="token punctuation">-</span> toYaml . <span class="token punctuation">|</span> nindent 8 <span class="token punctuation">}</span><span class="token punctuation">}</span>    <span class="token punctuation">{</span><span class="token punctuation">{</span><span class="token punctuation">-</span> end <span class="token punctuation">}</span><span class="token punctuation">}</span>      <span class="token key atrule">labels</span><span class="token punctuation">:</span>        <span class="token punctuation">{</span><span class="token punctuation">{</span><span class="token punctuation">-</span> include "nginx.selectorLabels" . <span class="token punctuation">|</span> nindent 8 <span class="token punctuation">}</span><span class="token punctuation">}</span>    <span class="token key atrule">spec</span><span class="token punctuation">:</span>      <span class="token punctuation">{</span><span class="token punctuation">{</span><span class="token punctuation">-</span> with .Values.imagePullSecrets <span class="token punctuation">}</span><span class="token punctuation">}</span>      <span class="token key atrule">imagePullSecrets</span><span class="token punctuation">:</span>        <span class="token punctuation">{</span><span class="token punctuation">{</span><span class="token punctuation">-</span> toYaml . <span class="token punctuation">|</span> nindent 8 <span class="token punctuation">}</span><span class="token punctuation">}</span>      <span class="token punctuation">{</span><span class="token punctuation">{</span><span class="token punctuation">-</span> end <span class="token punctuation">}</span><span class="token punctuation">}</span>      <span class="token key atrule">serviceAccountName</span><span class="token punctuation">:</span> <span class="token punctuation">{</span><span class="token punctuation">{</span> include "nginx.serviceAccountName" . <span class="token punctuation">}</span><span class="token punctuation">}</span>      <span class="token key atrule">securityContext</span><span class="token punctuation">:</span>        <span class="token punctuation">{</span><span class="token punctuation">{</span><span class="token punctuation">-</span> toYaml .Values.podSecurityContext <span class="token punctuation">|</span> nindent 8 <span class="token punctuation">}</span><span class="token punctuation">}</span>      <span class="token key atrule">containers</span><span class="token punctuation">:</span>        <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> <span class="token punctuation">{</span><span class="token punctuation">{</span> .Chart.Name <span class="token punctuation">}</span><span class="token punctuation">}</span>          <span class="token key atrule">securityContext</span><span class="token punctuation">:</span>            <span class="token punctuation">{</span><span class="token punctuation">{</span><span class="token punctuation">-</span> toYaml .Values.securityContext <span class="token punctuation">|</span> nindent 12 <span class="token punctuation">}</span><span class="token punctuation">}</span>          <span class="token key atrule">image</span><span class="token punctuation">:</span> <span class="token string">"{{ .Values.image.repository }}:{{ .Values.image.tag | default .Chart.AppVersion }}"</span>          <span class="token key atrule">imagePullPolicy</span><span class="token punctuation">:</span> <span class="token punctuation">{</span><span class="token punctuation">{</span> .Values.image.pullPolicy <span class="token punctuation">}</span><span class="token punctuation">}</span>          <span class="token key atrule">ports</span><span class="token punctuation">:</span>            <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> http              <span class="token key atrule">containerPort</span><span class="token punctuation">:</span> <span class="token number">80</span>              <span class="token key atrule">protocol</span><span class="token punctuation">:</span> TCP          <span class="token key atrule">livenessProbe</span><span class="token punctuation">:</span>            <span class="token key atrule">httpGet</span><span class="token punctuation">:</span>              <span class="token key atrule">path</span><span class="token punctuation">:</span> /              <span class="token key atrule">port</span><span class="token punctuation">:</span> http          <span class="token key atrule">readinessProbe</span><span class="token punctuation">:</span>            <span class="token key atrule">httpGet</span><span class="token punctuation">:</span>              <span class="token key atrule">path</span><span class="token punctuation">:</span> /              <span class="token key atrule">port</span><span class="token punctuation">:</span> http          <span class="token key atrule">resources</span><span class="token punctuation">:</span>            <span class="token punctuation">{</span><span class="token punctuation">{</span><span class="token punctuation">-</span> toYaml .Values.resources <span class="token punctuation">|</span> nindent 12 <span class="token punctuation">}</span><span class="token punctuation">}</span>      <span class="token punctuation">{</span><span class="token punctuation">{</span><span class="token punctuation">-</span> with .Values.nodeSelector <span class="token punctuation">}</span><span class="token punctuation">}</span>      <span class="token key atrule">nodeSelector</span><span class="token punctuation">:</span>        <span class="token punctuation">{</span><span class="token punctuation">{</span><span class="token punctuation">-</span> toYaml . <span class="token punctuation">|</span> nindent 8 <span class="token punctuation">}</span><span class="token punctuation">}</span>      <span class="token punctuation">{</span><span class="token punctuation">{</span><span class="token punctuation">-</span> end <span class="token punctuation">}</span><span class="token punctuation">}</span>      <span class="token punctuation">{</span><span class="token punctuation">{</span><span class="token punctuation">-</span> with .Values.affinity <span class="token punctuation">}</span><span class="token punctuation">}</span>      <span class="token key atrule">affinity</span><span class="token punctuation">:</span>        <span class="token punctuation">{</span><span class="token punctuation">{</span><span class="token punctuation">-</span> toYaml . <span class="token punctuation">|</span> nindent 8 <span class="token punctuation">}</span><span class="token punctuation">}</span>      <span class="token punctuation">{</span><span class="token punctuation">{</span><span class="token punctuation">-</span> end <span class="token punctuation">}</span><span class="token punctuation">}</span>      <span class="token punctuation">{</span><span class="token punctuation">{</span><span class="token punctuation">-</span> with .Values.tolerations <span class="token punctuation">}</span><span class="token punctuation">}</span>      <span class="token key atrule">tolerations</span><span class="token punctuation">:</span>        <span class="token punctuation">{</span><span class="token punctuation">{</span><span class="token punctuation">-</span> toYaml . <span class="token punctuation">|</span> nindent 8 <span class="token punctuation">}</span><span class="token punctuation">}</span>      <span class="token punctuation">{</span><span class="token punctuation">{</span><span class="token punctuation">-</span> end <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在<code>templates</code>目录下<code>yaml</code>文件中的变量，是在<code>nginx/values.yaml</code>中定义的，只需要修改<code>nginx/values.yaml</code>的内容，也就完成了<code>templates</code>目录下<code>yaml</code>文件的配置。</p><h4 id="修改"><a href="#修改" class="headerlink" title="修改"></a>修改</h4><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">vim nginx/Chart.yaml<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> v2<span class="token key atrule">name</span><span class="token punctuation">:</span> nginx<span class="token key atrule">description</span><span class="token punctuation">:</span> A Helm chart for Kubernetes<span class="token key atrule">type</span><span class="token punctuation">:</span> application <span class="token comment">#chart类型，application或library</span><span class="token key atrule">version</span><span class="token punctuation">:</span> 0.1.0 <span class="token comment">#chart版本</span><span class="token key atrule">appVersion</span><span class="token punctuation">:</span> 1.0.0 <span class="token comment">#application部署版本```</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">vim tomcat/values.yaml<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">replicaCount</span><span class="token punctuation">:</span> <span class="token number">1</span><span class="token key atrule">image</span><span class="token punctuation">:</span>  <span class="token key atrule">repository</span><span class="token punctuation">:</span> nginx  <span class="token key atrule">pullPolicy</span><span class="token punctuation">:</span> IfNotPresent  <span class="token key atrule">tag</span><span class="token punctuation">:</span> <span class="token string">"latest"</span><span class="token key atrule">imagePullSecrets</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token key atrule">nameOverride</span><span class="token punctuation">:</span> <span class="token string">""</span><span class="token key atrule">fullnameOverride</span><span class="token punctuation">:</span> <span class="token string">""</span><span class="token key atrule">serviceAccount</span><span class="token punctuation">:</span>  <span class="token key atrule">create</span><span class="token punctuation">:</span> <span class="token boolean important">true</span>  <span class="token key atrule">annotations</span><span class="token punctuation">:</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>  <span class="token key atrule">name</span><span class="token punctuation">:</span> <span class="token string">""</span><span class="token key atrule">podAnnotations</span><span class="token punctuation">:</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token key atrule">podSecurityContext</span><span class="token punctuation">:</span>  <span class="token punctuation">{</span><span class="token punctuation">}</span>  <span class="token comment"># fsGroup: 2000</span><span class="token key atrule">securityContext</span><span class="token punctuation">:</span>  <span class="token punctuation">{</span><span class="token punctuation">}</span>  <span class="token comment"># capabilities:</span>  <span class="token comment">#   drop:</span>  <span class="token comment">#   - ALL</span>  <span class="token comment"># readOnlyRootFilesystem: true</span>  <span class="token comment"># runAsNonRoot: true</span>  <span class="token comment"># runAsUser: 1000</span><span class="token key atrule">service</span><span class="token punctuation">:</span>  <span class="token key atrule">type</span><span class="token punctuation">:</span> ClusterIP  <span class="token key atrule">port</span><span class="token punctuation">:</span> <span class="token number">80</span><span class="token key atrule">ingress</span><span class="token punctuation">:</span>  <span class="token key atrule">enabled</span><span class="token punctuation">:</span> <span class="token boolean important">true</span>  <span class="token key atrule">annotations</span><span class="token punctuation">:</span>    <span class="token punctuation">{</span><span class="token punctuation">}</span>    <span class="token comment"># kubernetes.io/ingress.class: nginx</span>    <span class="token comment"># kubernetes.io/tls-acme: "true"</span>  <span class="token key atrule">hosts</span><span class="token punctuation">:</span>    <span class="token punctuation">-</span> <span class="token key atrule">host</span><span class="token punctuation">:</span> nginx.lzxlinux.cn <span class="token comment">#指定ingress域名及路径</span>      <span class="token key atrule">paths</span><span class="token punctuation">:</span> <span class="token punctuation">[</span>/<span class="token punctuation">]</span>  <span class="token key atrule">tls</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>  <span class="token comment">#  - secretName: chart-example-tls</span>  <span class="token comment">#    hosts:</span>  <span class="token comment">#      - chart-example.local</span><span class="token key atrule">resources</span><span class="token punctuation">:</span>  <span class="token key atrule">limits</span><span class="token punctuation">:</span>    <span class="token key atrule">cpu</span><span class="token punctuation">:</span> 100m    <span class="token key atrule">memory</span><span class="token punctuation">:</span> 128Mi  <span class="token key atrule">requests</span><span class="token punctuation">:</span>    <span class="token key atrule">cpu</span><span class="token punctuation">:</span> 100m    <span class="token key atrule">memory</span><span class="token punctuation">:</span> 128Mi<span class="token key atrule">autoscaling</span><span class="token punctuation">:</span>  <span class="token key atrule">enabled</span><span class="token punctuation">:</span> <span class="token boolean important">false</span>  <span class="token key atrule">minReplicas</span><span class="token punctuation">:</span> <span class="token number">1</span>  <span class="token key atrule">maxReplicas</span><span class="token punctuation">:</span> <span class="token number">100</span>  <span class="token key atrule">targetCPUUtilizationPercentage</span><span class="token punctuation">:</span> <span class="token number">80</span>  <span class="token comment"># targetMemoryUtilizationPercentage: 80</span><span class="token key atrule">nodeSelector</span><span class="token punctuation">:</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token key atrule">tolerations</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token key atrule">affinity</span><span class="token punctuation">:</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h4><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">helm install nginx nginx --dry-run --debug                #渲染输出，不进行安装helm install nginx nginx -n default             #部署chart，release版本默认为1helm lsNAME NAMESPACEREVISIONUPDATED                               STATUS  CHART      APP VERSIONnginxdefault  1       2020-08-19 16:39:48.80635996 +0800 CSTdeployednginx-0.1.01.0.0kubectl get podNAME                     READY   STATUS    RESTARTS   AGEnginx-74865b6d4c-867vm   1/1     Running   0          28skubectl get svcNAME         TYPE        CLUSTER-IP      EXTERNAL-IP   PORT(S)   AGEkubernetes   ClusterIP   10.96.0.1       &lt;none&gt;        443/TCP   8dnginx        ClusterIP   10.108.89.192   &lt;none&gt;        80/TCP    34skubectl get ingressNAME    CLASS    HOSTS               ADDRESS   PORTS   AGEnginx   &lt;none&gt;   nginx.lzxlinux.cn             80      38s<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="升级"><a href="#升级" class="headerlink" title="升级"></a>升级</h4><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">helm upgrade nginx nginx                #升级release，release版本加1kubectl get svcNAME         TYPE        CLUSTER-IP      EXTERNAL-IP   PORT(S)        AGEkubernetes   ClusterIP   10.96.0.1       &lt;none&gt;        443/TCP        8dnginx        NodePort    10.108.89.192   &lt;none&gt;        80:30080/TCP   14m<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="回滚"><a href="#回滚" class="headerlink" title="回滚"></a>回滚</h4><p>可以根据 release 版本回滚，</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">helm history nginx                  #查看release版本历史REVISIONUPDATED                 STATUS    CHART      APP VERSIONDESCRIPTION1       Wed Aug 19 16:39:48 2020supersedednginx-0.1.01.0.0      Install complete2       Wed Aug 19 16:52:14 2020deployed  nginx-0.1.01.0.0      Upgrade complete<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">helm rollback nginx 1               #回滚release到版本1Rollback was a success! Happy Helming!<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">helm history nginxREVISIONUPDATED                 STATUS    CHART      APP VERSIONDESCRIPTION1       Wed Aug 19 16:39:48 2020supersedednginx-0.1.01.0.0      Install complete2       Wed Aug 19 16:52:14 2020supersedednginx-0.1.01.0.0      Upgrade complete3       Wed Aug 19 16:58:36 2020deployed  nginx-0.1.01.0.0      Rollback to 1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">kubectl get svcNAME         TYPE        CLUSTER-IP      EXTERNAL-IP   PORT(S)   AGEkubernetes   ClusterIP   10.96.0.1       &lt;none&gt;        443/TCP   8dnginx        ClusterIP   10.108.89.192   &lt;none&gt;        80/TCP    19m<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">kubectl get ingressNAME    CLASS    HOSTS               ADDRESS   PORTS   AGEnginx   &lt;none&gt;   nginx.lzxlinux.cn             80      56s<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>可以看到，nginx release 已经回滚到版本 1。<br>通常情况下，在配置好 templates 目录下的 kubernetes 清单文件后，后续维护只需要修改 Chart.yaml 和 values.yaml 即可。</p><h3 id="创建-Helm-仓库"><a href="#创建-Helm-仓库" class="headerlink" title="创建 Helm 仓库"></a>创建 Helm 仓库</h3><p>Helm 可以使用私有 Helm 仓库，将自定义的 Chart 推送至仓库。</p><h4 id="安装-Push-插件"><a href="#安装-Push-插件" class="headerlink" title="安装 Push 插件"></a>安装 Push 插件</h4><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">helm plugin install https://github.com/chartmuseum/helm-pushhelm plugin lsNAMEVERSIONDESCRIPTIONpush0.8.1  Push chart package to ChartMuseum<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="添加-Repo"><a href="#添加-Repo" class="headerlink" title="添加 Repo"></a>添加 Repo</h4><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">helm repo add reponame http://repourl/reponame/chartname --username=yourname --password=yourpwdhelm repo lsNAME  URLstablehttp://mirror.azure.cn/kubernetes/chartsaliyunhttps://kubernetes.oss-cn-hangzhou.aliyuncs.com/chartsreponamehttp://repourl/reponame/chartnamecd /softwarehelm push nginx reponamePushing nginx-0.1.0.tgz to harbor...Done.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="关于-Chart"><a href="#关于-Chart" class="headerlink" title="关于 Chart"></a>关于 Chart</h2><p>Chart 是描述一组 Kubernetes 资源文件的集合。单个 Chart 既可以用于部署简单的应用(单个服务)，也可以部署复杂的应用(多个服务、高可用架构)。<br>使用 <code>helm create &lt;chart name&gt;</code> 命令，可以创建特定结构的目录及文件，之后可以将它们打包到版本存档中进行部署。<br>如果要下载并查看已发布 chart 的文件而不安装它，则可以使用 <code>helm pull &lt;chart repo&gt;/&lt;chart name&gt;</code> 进行操作。</p><h3 id="文件结构"><a href="#文件结构" class="headerlink" title="文件结构"></a>文件结构</h3><p>Chart 被组织为目录内文件的集合，目录名称就是 Chart 的名称（不包含版本信息）。因此，描述 WordPress 的 Chart 将存储在 wordpress/目录中。</p><p>而在此目录中，Helm 将期望与以下内容匹配的结构：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">wordpress/  Chart.yaml            # 包含chart信息的YAML文件  LICENSE               # 包含chart许可的纯文本文件（可选）  README.md             # README自述文件（可选）  values.yaml           # 此chart的默认配置值  values.schema.json    # 用于在 values.yaml 上强加结构的JSON模式（可选）  charts/               # 包含此chart所依赖的任何charts的目录  crds/                 # 自定义资源定义（CRD）  templates/            # 模板目录，与值结合时，将生成有效的Kubernetes清单文件  templates/NOTES.txt   # 包含简短用法说明的纯文本文件（可选）<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Helm 保留了 charts/、crds/和 templates/目录的使用，以及列出的文件名。其他文件将保持原样。</p><h3 id="Chart-yaml"><a href="#Chart-yaml" class="headerlink" title="Chart.yaml"></a>Chart.yaml</h3><p>Chart.yaml 文件是 Chart 所必需的。它包含以下字段:</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> <span class="token comment"># chart API版本 (必需)</span><span class="token key atrule">name</span><span class="token punctuation">:</span> <span class="token comment"># chart 名称 (必需)</span><span class="token key atrule">version</span><span class="token punctuation">:</span> <span class="token comment"># 版本 (必需, SemVer 2标准)</span><span class="token key atrule">kubeVersion</span><span class="token punctuation">:</span> <span class="token comment"># 所有兼容的Kubernetes 版本 (可选, SemVer 2标准)</span><span class="token key atrule">description</span><span class="token punctuation">:</span> <span class="token comment"># 项目单句描述 (可选)</span><span class="token key atrule">type</span><span class="token punctuation">:</span> <span class="token comment"># chart 类型，application 和 library (可选)</span><span class="token key atrule">keywords</span><span class="token punctuation">:</span>  <span class="token punctuation">-</span>  <span class="token comment"># 关于项目的关键字列表 (可选)</span><span class="token key atrule">home</span><span class="token punctuation">:</span> <span class="token comment"># 项目主页的url (可选)</span><span class="token key atrule">sources</span><span class="token punctuation">:</span>  <span class="token punctuation">-</span>  <span class="token comment"># 项目源码的url列表 (可选)</span><span class="token key atrule">dependencies</span><span class="token punctuation">:</span> <span class="token comment"># chart 需求列表 (可选)</span>  <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> <span class="token comment"># chart 名称 (nginx)</span>    <span class="token key atrule">version</span><span class="token punctuation">:</span> <span class="token comment"># chart 版本 ("1.2.3")</span>    <span class="token key atrule">repository</span><span class="token punctuation">:</span> <span class="token comment"># repo url ("https://example.com/charts") 或 别名 ("@repo-name")</span>    <span class="token key atrule">condition</span><span class="token punctuation">:</span> <span class="token comment"># 一个解析为boolean的yaml路径，用于 启用/禁用 charts (如 subchart1.enabled ) (可选)</span>    <span class="token key atrule">tags</span><span class="token punctuation">:</span> <span class="token comment"># (可选)</span>      <span class="token punctuation">-</span>  <span class="token comment"># Tags 可以用来对 charts 的 启用/禁用 分组 (可选)</span>    <span class="token key atrule">enabled</span><span class="token punctuation">:</span> <span class="token comment"># 使用 bool 参数决定是否应该加载 chart (可选)</span>    <span class="token key atrule">import-values</span><span class="token punctuation">:</span> <span class="token comment"># (可选)</span>      <span class="token punctuation">-</span>  <span class="token comment"># ImportValues 保存源值到要导入父键的映射。每一项可以是一个字符串或一对子/父子列表项 (可选)</span>    <span class="token key atrule">alias</span><span class="token punctuation">:</span> <span class="token comment"># 用于 chart 的别名。多次添加相同的 chart 时很有用 (可选)</span><span class="token key atrule">maintainers</span><span class="token punctuation">:</span> <span class="token comment"># (可选)</span>  <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> <span class="token comment"># 维护人员名称 (每个维护人员必需)</span>    <span class="token key atrule">email</span><span class="token punctuation">:</span> <span class="token comment"># 维护人员email (每个维护人员可选)</span>    <span class="token key atrule">url</span><span class="token punctuation">:</span> <span class="token comment"># 维护人员的url (每个维护人员可选)</span><span class="token key atrule">icon</span><span class="token punctuation">:</span> <span class="token comment"># 作为图标使用的 SVG 或 PNG 图片 的url (可选)</span><span class="token key atrule">appVersion</span><span class="token punctuation">:</span> <span class="token comment"># app 版本 (可选)</span><span class="token key atrule">deprecated</span><span class="token punctuation">:</span> <span class="token comment"># chart 是否已弃用 (可选, boolean)</span><span class="token key atrule">annotations</span><span class="token punctuation">:</span>  <span class="token key atrule">example</span><span class="token punctuation">:</span> <span class="token comment"># 按名称键入的注释列表 (可选)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="Chart-依赖"><a href="#Chart-依赖" class="headerlink" title="Chart 依赖"></a>Chart 依赖</h3><p>Helm 中，一个 Chart 可能会依赖任意数量的其它 Chart。这些依赖项可以在 Chart.yaml 中通过 dependencies 字段进行动态配置，也可以导入 charts/目录中并手动进行管理。</p><p>当前 Chart 所依赖的 Chart 在 dependencies 字段中定义为列表：</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">dependencies</span><span class="token punctuation">:</span>  <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> apache    <span class="token key atrule">version</span><span class="token punctuation">:</span> 1.2.3    <span class="token key atrule">repository</span><span class="token punctuation">:</span> https<span class="token punctuation">:</span>//example.com/charts  <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> mysql    <span class="token key atrule">version</span><span class="token punctuation">:</span> 3.2.1    <span class="token key atrule">repository</span><span class="token punctuation">:</span> https<span class="token punctuation">:</span>//another.example.com/charts<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>repository 字段是 chart repo 的完整 url。需要注意的是，必须使用 helm repo add <repo url="">本地添加该 repo。可以使用存储库的名称代替 url。</repo></p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">helm repo add example-charts https://example.com/charts<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">dependencies</span><span class="token punctuation">:</span>  <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> apache    <span class="token key atrule">version</span><span class="token punctuation">:</span> 1.2.3    <span class="token key atrule">repository</span><span class="token punctuation">:</span> <span class="token string">"@example-charts"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>定义依赖项后，可以运行 helm dependency update <chart name="">，它将使用依赖项文件将所有指定的 Chart 下载到您的 charts/目录中。</chart></p><h3 id="依赖项别名"><a href="#依赖项别名" class="headerlink" title="依赖项别名"></a>依赖项别名</h3><p>除上述字段外，每个依赖项都可以包含可选字段 Alias。</p><p>为依赖的 Chart 添加别名，将 Chart 置于依赖关系中时将使用别名作为依赖项的名称。</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">dependencies</span><span class="token punctuation">:</span>  <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> subchart    <span class="token key atrule">repository</span><span class="token punctuation">:</span> http<span class="token punctuation">:</span>//localhost<span class="token punctuation">:</span><span class="token number">10191</span>    <span class="token key atrule">version</span><span class="token punctuation">:</span> 0.1.0    <span class="token key atrule">alias</span><span class="token punctuation">:</span> new<span class="token punctuation">-</span>subchart<span class="token punctuation">-</span><span class="token number">1</span>  <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> subchart    <span class="token key atrule">repository</span><span class="token punctuation">:</span> http<span class="token punctuation">:</span>//localhost<span class="token punctuation">:</span><span class="token number">10191</span>    <span class="token key atrule">version</span><span class="token punctuation">:</span> 0.1.0    <span class="token key atrule">alias</span><span class="token punctuation">:</span> new<span class="token punctuation">-</span>subchart<span class="token punctuation">-</span><span class="token number">2</span>  <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> subchart    <span class="token key atrule">repository</span><span class="token punctuation">:</span> http<span class="token punctuation">:</span>//localhost<span class="token punctuation">:</span><span class="token number">10191</span>    <span class="token key atrule">version</span><span class="token punctuation">:</span> 0.1.0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在上面的示例中，将获得 3 个依赖项：</p><ul><li>subchart</li><li>new-subchart-1</li><li>new-subchart-2</li></ul><h3 id="依赖项标签和条件"><a href="#依赖项标签和条件" class="headerlink" title="依赖项标签和条件"></a>依赖项标签和条件</h3><p>除上述字段外，每个依赖项还可以包含可选字段 Tags 和 Condition。</p><p>默认情况下会加载所有 Chart。如果存在 Tags 或 Condition 字段，则它们将被用于控制应用它们的 Chart 的加载。</p><p>Condition 字段包含一个或多个 Yaml 路径（以逗号分隔）。如果此路径存在于父 Chart 的 Values 中并解析为布尔值，则将基于该布尔值 启用/禁用 Chart。仅列表中找到的第一个路径有效，如果不存在路径，则该条件无效。</p><p>Tags 字段是与该 Chart 关联的 Yaml 标签列表。在父 Chart 的 Values 中，可以通过指定标签和布尔值来 启用/禁用 所有带有标签的 chart。</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">dependencies</span><span class="token punctuation">:</span>  <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> subchart1    <span class="token key atrule">repository</span><span class="token punctuation">:</span> http<span class="token punctuation">:</span>//localhost<span class="token punctuation">:</span><span class="token number">10191</span>    <span class="token key atrule">version</span><span class="token punctuation">:</span> 0.1.0    <span class="token key atrule">condition</span><span class="token punctuation">:</span> subchart1.enabled<span class="token punctuation">,</span> global.subchart1.enabled    <span class="token key atrule">tags</span><span class="token punctuation">:</span>      <span class="token punctuation">-</span> front<span class="token punctuation">-</span>end      <span class="token punctuation">-</span> subchart1  <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> subchart2    <span class="token key atrule">repository</span><span class="token punctuation">:</span> http<span class="token punctuation">:</span>//localhost<span class="token punctuation">:</span><span class="token number">10191</span>    <span class="token key atrule">version</span><span class="token punctuation">:</span> 0.1.0    <span class="token key atrule">condition</span><span class="token punctuation">:</span> subchart2.enabled<span class="token punctuation">,</span>global.subchart2.enabled    <span class="token key atrule">tags</span><span class="token punctuation">:</span>      <span class="token punctuation">-</span> back<span class="token punctuation">-</span>end      <span class="token punctuation">-</span> subchart2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>values.yaml</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">subchart1</span><span class="token punctuation">:</span>  <span class="token key atrule">enabled</span><span class="token punctuation">:</span> <span class="token boolean important">true</span><span class="token key atrule">tags</span><span class="token punctuation">:</span>  <span class="token key atrule">front-end</span><span class="token punctuation">:</span> <span class="token boolean important">false</span>  <span class="token key atrule">back-end</span><span class="token punctuation">:</span> <span class="token boolean important">true</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上面示例中，所有带有标签 front-end 都将被禁用，但是由于 subchart1.enabled 路径在父 chart 的 Values 中为 true，因此条件将覆盖 front-end 标签并启用 subchart1。</p><p>由于 subchart2 带有标签 back-end，且 back-end 为 true，subchart2 将被启用。另外，尽管 subchart2 指定了条件，但父 Chart 的 Values 中没有相应的路径和值，因此该条件无效。</p><p><code>--set</code>参数可以用于更改标签和条件值</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">helm install --set tags.front-end=true --set subchart2.enabled=false<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="标签和条件解析"><a href="#标签和条件解析" class="headerlink" title="标签和条件解析"></a>标签和条件解析</h3><ul><li><p>条件（有设置时）始终会覆盖标签。存在的第一个条件路径获胜，后续条件路径将被忽略</p></li><li><p>如果 chart 的任何标签为 true，则启用该 chart</p></li><li><p>标签和条件值必须设置在父 chart 的 Values 中</p></li><li><p>tags：父 chart 的 Values 中的键必须是顶级键；不支持全局和嵌套表</p></li></ul><h2 id="Helm-内置对象"><a href="#Helm-内置对象" class="headerlink" title="Helm 内置对象"></a>Helm 内置对象</h2><p>对象从模板引擎传递到模板中。</p><p>对象可以很简单，只有一个值；或者可以包含其他对象或函数。例如，<code>Release</code> 对象包含多个对象（如 <code>Release.Name</code>）并且 Files 对象具有一些函数。</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">Release</span><span class="token punctuation">:</span> 此对象描述发行版本身。它里面有几个对象<span class="token punctuation">-</span> <span class="token key atrule">Release.Name</span><span class="token punctuation">:</span> release 名称<span class="token punctuation">-</span> <span class="token key atrule">Release.Namespace</span><span class="token punctuation">:</span> release 的 namespace（如果清单未覆盖）<span class="token punctuation">-</span> <span class="token key atrule">Release.IsUpgrade</span><span class="token punctuation">:</span> 如果当前操作是upgrade或rollback，则设置为 true<span class="token punctuation">-</span> <span class="token key atrule">Release.IsInstall</span><span class="token punctuation">:</span> 如果当前操作是install，则设置为 true<span class="token punctuation">-</span> <span class="token key atrule">Release.Revision</span><span class="token punctuation">:</span> release的版本号。初始部署时为1，并且每次升级或回滚时加1<span class="token punctuation">-</span> <span class="token key atrule">Release.Service</span><span class="token punctuation">:</span> release 服务的名称。在Helm上，始终是Helm<span class="token key atrule">Values</span><span class="token punctuation">:</span> 从 values.yaml 文件和用户提供的文件传入模板的值，默认情况下 Values 为空<span class="token key atrule">Chart</span><span class="token punctuation">:</span> Chart.yaml 文件的内容。Chart.yaml 中的任何数据都可以在此处访问<span class="token key atrule">Files</span><span class="token punctuation">:</span> 提供对 chart 中所有非特殊文件的访问。不能使用它来访问模板，但是可以使用它来访问 chart 中的其他文件：<span class="token punctuation">-</span> <span class="token key atrule">Files.Get</span><span class="token punctuation">:</span> 是用于通过名称（.Files.Get config.ini）获取文件的函数<span class="token punctuation">-</span> <span class="token key atrule">Files.GetBytes</span><span class="token punctuation">:</span> 是将文件内容作为字节数组而不是字符串获取的函数<span class="token punctuation">-</span> <span class="token key atrule">Files.Glob</span><span class="token punctuation">:</span> 是一个函数，该函数返回名称与给定的Shell Glob模式匹配的文件列表<span class="token punctuation">-</span> <span class="token key atrule">Files.Lines</span><span class="token punctuation">:</span> 是逐行读取文件的函数，对于遍历文件很有用<span class="token punctuation">-</span> <span class="token key atrule">Files.AsSecrets</span><span class="token punctuation">:</span> 是将文件主体作为Base64编码的字符串返回的函数<span class="token punctuation">-</span> <span class="token key atrule">Files.AsConfig</span><span class="token punctuation">:</span> 是一个将文件正文作为YAML映射返回的函数<span class="token key atrule">Capabilities</span><span class="token punctuation">:</span> 提供了有关Kubernetes集群支持哪些功能的信息<span class="token punctuation">-</span> <span class="token key atrule">Capabilities.APIVersions</span><span class="token punctuation">:</span> 是一组版本<span class="token punctuation">-</span> <span class="token key atrule">Capabilities.APIVersions.Has $version</span><span class="token punctuation">:</span> 指示版本（例如 batch/v1）或资源（例如 apps/v1/Deployment）在集群上是否可用<span class="token punctuation">-</span> <span class="token key atrule">Capabilities.KubeVersion 和 Capabilities.KubeVersion.Version</span><span class="token punctuation">:</span> 是Kubernetes版本<span class="token punctuation">-</span> <span class="token key atrule">Capabilities.KubeVersion.Major</span><span class="token punctuation">:</span> 是Kubernetes的主要版本<span class="token punctuation">-</span> <span class="token key atrule">Capabilities.KubeVersion.Minor</span><span class="token punctuation">:</span> 是Kubernetes的次要版本<span class="token key atrule">Template</span><span class="token punctuation">:</span> 包含有关正在执行的当前模板的信息    <span class="token key atrule">Template.Name</span><span class="token punctuation">:</span> 当前模板的命名空间文件路径（例如 mychart/templates/mytemplate.yaml）    <span class="token key atrule">Template.BasePath</span><span class="token punctuation">:</span> 当前 chart 的模板目录的命名空间路径（例如 mychart/templates）<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上⾯的值可用于任何顶级模板，要注意内置值始终以大写字母开头。</p><h3 id="values-yaml"><a href="#values-yaml" class="headerlink" title="values.yaml"></a>values.yaml</h3><p>helm 模板提供的内置对象之一是 <code>Values</code>，该对象提供对传递到 chart 中的值的访问。其内容来自多种来源：</p><ol><li>chart 中的 values.yaml 文件</li><li>如果是子 chart，则是父 chart 中的 values.yaml 文件</li><li>helm install 或 helm upgrade 带的 -f 参数指定的 yaml 文件（如 helm install -f myvals.yaml ./mychart）</li><li>通过 –set 参数传递的值（如 helm install –set foo=bar ./mychart）</li></ol><p>上面按顺序排列：values.yaml 是默认值，可以被父 chart 的 values.yaml 覆盖，而后者可以由用户提供的 yaml 文件覆盖，而后者又可以由 –set 参数覆盖。</p><p>示例 values.yaml</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">favorite</span><span class="token punctuation">:</span>  <span class="token key atrule">drink</span><span class="token punctuation">:</span> coffee  <span class="token key atrule">food</span><span class="token punctuation">:</span> pizza<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>根据示例 values.yaml，可以这样修改模板：</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> v1<span class="token key atrule">kind</span><span class="token punctuation">:</span> ConfigMap<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">name</span><span class="token punctuation">:</span> <span class="token punctuation">{</span><span class="token punctuation">{</span> .Release.Name <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">-</span>configmap<span class="token key atrule">data</span><span class="token punctuation">:</span>  <span class="token key atrule">myvalue</span><span class="token punctuation">:</span> <span class="token string">"Hello World"</span>  <span class="token key atrule">drink</span><span class="token punctuation">:</span> <span class="token punctuation">{</span><span class="token punctuation">{</span> .Values.favorite.drink <span class="token punctuation">}</span><span class="token punctuation">}</span>  <span class="token key atrule">food</span><span class="token punctuation">:</span> <span class="token punctuation">{</span><span class="token punctuation">{</span> .Values.favorite.food <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="模板函数和管道"><a href="#模板函数和管道" class="headerlink" title="模板函数和管道"></a>模板函数和管道</h3><p>当将 .Values 对象中的字符串注入到模板时，可以通过调用模板函数 quote 来引用这些字符串：</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> v1<span class="token key atrule">kind</span><span class="token punctuation">:</span> ConfigMap<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">name</span><span class="token punctuation">:</span> <span class="token punctuation">{</span><span class="token punctuation">{</span> .Release.Name <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">-</span>configmap<span class="token key atrule">data</span><span class="token punctuation">:</span>  <span class="token key atrule">myvalue</span><span class="token punctuation">:</span> <span class="token string">"Hello World"</span>  <span class="token key atrule">drink</span><span class="token punctuation">:</span> <span class="token punctuation">{</span><span class="token punctuation">{</span> quote .Values.favorite.drink <span class="token punctuation">}</span><span class="token punctuation">}</span>  <span class="token key atrule">food</span><span class="token punctuation">:</span> <span class="token punctuation">{</span><span class="token punctuation">{</span> quote .Values.favorite.food <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>模板函数遵循语法：functionName arg1 arg2…，在上面代码段中，quote .Values.favorite.drink 调用 quote 函数并将其传递给单个参数。</p><h4 id="管道-‘-’"><a href="#管道-‘-’" class="headerlink" title="管道 ‘|’"></a>管道 ‘|’</h4><p>管道 <code>|</code> 是将一系列模板命令链接在一起的工具，以紧凑地表达一系列转换。管道 <code>|</code> 是按顺序完成多项工作的有效方式。</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> v1<span class="token key atrule">kind</span><span class="token punctuation">:</span> ConfigMap<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">name</span><span class="token punctuation">:</span> <span class="token punctuation">{</span><span class="token punctuation">{</span> .Release.Name <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">-</span>configmap<span class="token key atrule">data</span><span class="token punctuation">:</span>  <span class="token key atrule">myvalue</span><span class="token punctuation">:</span> <span class="token string">"Hello World"</span>  <span class="token key atrule">drink</span><span class="token punctuation">:</span> <span class="token punctuation">{</span><span class="token punctuation">{</span> .Values.favorite.drink <span class="token punctuation">|</span> quote <span class="token punctuation">}</span><span class="token punctuation">}</span>  <span class="token key atrule">food</span><span class="token punctuation">:</span> <span class="token punctuation">{</span><span class="token punctuation">{</span> .Values.favorite.food <span class="token punctuation">|</span> quote <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上面示例中，没有调用，而是反转了顺序。使用管道 <code>|</code> 将参数“发送”到函数：<code>.Values.favorite.food | quote</code></p><pre><code>反转顺序是模板中的常见做法，.val | quote 比 quote .val 更为常见。</code></pre><p>使用管道，可以将多个功能链接在一起：</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> v1<span class="token key atrule">kind</span><span class="token punctuation">:</span> ConfigMap<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">name</span><span class="token punctuation">:</span> <span class="token punctuation">{</span><span class="token punctuation">{</span> .Release.Name <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">-</span>configmap<span class="token key atrule">data</span><span class="token punctuation">:</span>  <span class="token key atrule">myvalue</span><span class="token punctuation">:</span> <span class="token string">"Hello World"</span>  <span class="token key atrule">drink</span><span class="token punctuation">:</span> <span class="token punctuation">{</span><span class="token punctuation">{</span> .Values.favorite.drink <span class="token punctuation">|</span> quote <span class="token punctuation">}</span><span class="token punctuation">}</span>  <span class="token key atrule">food</span><span class="token punctuation">:</span> <span class="token punctuation">{</span><span class="token punctuation">{</span> .Values.favorite.food <span class="token punctuation">|</span> upper <span class="token punctuation">|</span> quote <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>该模板产生以下输出：</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> v1<span class="token key atrule">kind</span><span class="token punctuation">:</span> ConfigMap<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">name</span><span class="token punctuation">:</span> trendsetting<span class="token punctuation">-</span>p<span class="token punctuation">-</span>configmap<span class="token key atrule">data</span><span class="token punctuation">:</span>  <span class="token key atrule">myvalue</span><span class="token punctuation">:</span> <span class="token string">"Hello World"</span>  <span class="token key atrule">drink</span><span class="token punctuation">:</span> <span class="token string">"coffee"</span>  <span class="token key atrule">food</span><span class="token punctuation">:</span> <span class="token string">"PIZZA"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上面示例中，已经将 pizza 转换为 “PIZZA”。</p><h4 id="default-函数"><a href="#default-函数" class="headerlink" title="default 函数"></a>default 函数</h4><p>default 函数允许在模板内部指定默认值，以防省略该值。</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> v1<span class="token key atrule">kind</span><span class="token punctuation">:</span> ConfigMap<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">name</span><span class="token punctuation">:</span> <span class="token punctuation">{</span><span class="token punctuation">{</span> .Release.Name <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">-</span>configmap<span class="token key atrule">data</span><span class="token punctuation">:</span>  <span class="token key atrule">myvalue</span><span class="token punctuation">:</span> <span class="token string">"Hello World"</span>  <span class="token key atrule">drink</span><span class="token punctuation">:</span> <span class="token punctuation">{</span><span class="token punctuation">{</span> .Values.favorite.drink <span class="token punctuation">|</span> default "tea" <span class="token punctuation">|</span> quote <span class="token punctuation">}</span><span class="token punctuation">}</span>  <span class="token key atrule">food</span><span class="token punctuation">:</span> <span class="token punctuation">{</span><span class="token punctuation">{</span> .Values.favorite.food <span class="token punctuation">|</span> upper <span class="token punctuation">|</span> quote <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>values.yaml 中可以注释 drink，得到输出：</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> v1<span class="token key atrule">kind</span><span class="token punctuation">:</span> ConfigMap<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">name</span><span class="token punctuation">:</span> fair<span class="token punctuation">-</span>worm<span class="token punctuation">-</span>configmap<span class="token key atrule">data</span><span class="token punctuation">:</span>  <span class="token key atrule">myvalue</span><span class="token punctuation">:</span> <span class="token string">"Hello World"</span>  <span class="token key atrule">drink</span><span class="token punctuation">:</span> <span class="token string">"tea"</span>  <span class="token key atrule">food</span><span class="token punctuation">:</span> <span class="token string">"PIZZA"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在实际 Chart 中，所有默认值都应该配置在 values.yaml 中，并且不应使用 default 函数重复。</p><h4 id="lookup-函数"><a href="#lookup-函数" class="headerlink" title="lookup 函数"></a>lookup 函数</h4><p>lookup 函数可用于在运行中的集群中查找资源。</p><p>参数的组合：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">kubectl get pod mypod -n mynamespace  →   lookup "v1" "Pod" "mynamespace" "mypod"kubectl get pods -n mynamespace       →   lookup "v1" "Pod" "mynamespace" ""kubectl get pods --all-namespaces     →   lookup "v1" "Pod" "" ""kubectl get namespace mynamespace     →   lookup "v1" "Namespace" "" "mynamespace"kubectl get namespaces                →   lookup "v1" "Namespace" "" ""<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>当 lookup 返回一个对象时，它将返回一个字典，可以进一步从字典中提取特定值。</p><p>例如，返回该 mynamespace 对象存在的注释：</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml">(lookup "v1" "Namespace" "" "mynamespace").metadata.annotations<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>当 lookep 返回一个对象列表时，可以通过 items 字段访问对象列表：</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token punctuation">{</span><span class="token punctuation">{</span> range $index<span class="token punctuation">,</span> $service <span class="token punctuation">:</span>= (lookup "v1" "Service" "mynamespace" "").items <span class="token punctuation">}</span><span class="token punctuation">}</span>    <span class="token punctuation">{</span><span class="token punctuation">{</span>/* do something with each service <span class="token important">*/</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">{</span><span class="token punctuation">{</span> end <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>如果找不到对象，则返回一个空值。</p><p>lookup 函数使用 Helm 现有的 Kubernetes 连接配置来查询 Kubernetes。如果在与调用 API 服务器进行交互时返回任何错误（例如缺乏访问资源的权限），则模板处理将失败。</p><p>需要注意的是，在 helm template 或 helm install|update|delete|rollback –dry-run 期间，Helm 不会与 Kubernetes API Server 联系，因此在这种情况下 lookup 函数将返回 nil。</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">indent</span><span class="token punctuation">:</span> 从左到右指定空格个数<span class="token key atrule">with</span><span class="token punctuation">:</span> 可以允许将当前范围 . 设置为特定的对象。例如 .Values.service，使用 with 可以将 .Values.service 改为 .<span class="token key atrule">变量</span><span class="token punctuation">:</span> 在 Helm 模板中，变量是对另一个对象的命名引用。它遵循这个形式 $name。变量被赋予一个特殊的赋值操作符：<span class="token punctuation">:</span>=<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="Capabilities-APIVersions-Has-函数"><a href="#Capabilities-APIVersions-Has-函数" class="headerlink" title=".Capabilities.APIVersions.Has 函数"></a>.Capabilities.APIVersions.Has 函数</h4><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml">.Capabilities.APIVersions.Has 函数返回API版本或资源在集群中是否可用。.Capabilities.APIVersions.Has "apps/v1".Capabilities.APIVersions.Has "apps/v1/Deployment"<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h4 id="其它常用函数"><a href="#其它常用函数" class="headerlink" title="其它常用函数"></a>其它常用函数</h4><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">and         返回两个参数的布尔值和or          返回两个参数的布尔值或。它返回第一个非空参数或最后一个参数not         返回其参数的布尔取反eq          如果Arg1 = Arg2，则返回true，否则返回falsene          如果Arg1 != Arg2，则返回true，否则返回falselt          如果Arg1 &lt; Arg2，则返回true，否则返回falsele          如果Arg1 &lt;= Arg2，则返回true，否则返回falsegt          如果Arg1 &gt; Arg2，则返回true，否则返回falsege          如果Arg1 &gt;= Arg2，则返回true，否则返回falselower       将整个字符串转换为小写upper       将整个字符串转换为大写repeat      重复给定字符串多次substr      从字符串获取子字符串nospace     从字符串中删除所有空格indent      indent 函数将给定字符串中的每一行缩进到指定的缩进宽度nindent     nindent 函数与 indent 函数相同，但是在字符串的开头添加了新行replace     执行简单的字符串替换reverse     用给定列表的元素，生成一个新列表，顺序与原列表相反uniq        生成一个列表，删除所有重复项has         测试列表是否具有特定元素，返回true，否则返回falseslice       获取列表部分元素，列表切片until       生成一个顺序的整数列表untilStep   和 until 一样，生成一个顺序的整数列表，但 untilStep 允许定义开始、结束和步长seq         类似 seq 命令，生成参数之间的所有整数，默认步长为1或-1，单调递增或递减add         相加add1        加1sub         相减div         相除mul         相乘max         最大值min         最小值floor       返回 &lt;= 输入值的最大浮点数ceil        返回 &gt;= 输入值的最大浮点数round       四舍五入，返回一个浮点数len         以整数形式返回参数的长度base        返回路径的最后一个元素dir         返回目录，去除路径的最后一部分clean       清理路径，只保留路径开头和结尾ext         返回文件扩展名isAbs       检查文件路径是否是绝对路径<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Helm 包含许多模板函数，可以在模板中使用它们。常用函数：<a href="https://helm.sh/docs/chart_template_guide/function_list/">https://helm.sh/docs/chart_template_guide/function_list/</a></p><h2 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h2><p>控制结构（在模板中被称为“动作”）提供了控制模板生成流程的能力。helm 的模板语言提供以下控制结构：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">if/else     用于创建条件块with        指定范围range       提供“针对每个”样式的循环<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>除此之外，helm 还提供了一些声明和使用命名模板段的操作：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">define      在模板中声明一个新的命名模板template    导入命名模板block       声明一种特殊的可填充模板区域<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="if-else"><a href="#if-else" class="headerlink" title="if/else"></a>if/else</h3><h4 id="基础结构"><a href="#基础结构" class="headerlink" title="基础结构"></a>基础结构</h4><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token punctuation">{</span><span class="token punctuation">{</span> if PIPELINE <span class="token punctuation">}</span><span class="token punctuation">}</span>  <span class="token comment"># Do something</span><span class="token punctuation">{</span><span class="token punctuation">{</span> else if OTHER PIPELINE <span class="token punctuation">}</span><span class="token punctuation">}</span>  <span class="token comment"># Do something else</span><span class="token punctuation">{</span><span class="token punctuation">{</span> else <span class="token punctuation">}</span><span class="token punctuation">}</span>  <span class="token comment"># Default case</span><span class="token punctuation">{</span><span class="token punctuation">{</span> end <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果值为以下内容，pipeline 为 false：</p><ol><li>布尔值 false</li><li>数字 0</li><li>空字符串</li><li>nil（empty 或 null）</li><li>空集合（map，slice，tuple，dict，array）</li></ol><p>在其他条件下，pipeline 为 true。</p><p><strong>示例</strong></p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> v1<span class="token key atrule">kind</span><span class="token punctuation">:</span> ConfigMap<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">name</span><span class="token punctuation">:</span> <span class="token punctuation">{</span><span class="token punctuation">{</span> .Release.Name <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">-</span>configmap<span class="token key atrule">data</span><span class="token punctuation">:</span>  <span class="token key atrule">myvalue</span><span class="token punctuation">:</span> <span class="token string">"Hello World"</span>  <span class="token key atrule">drink</span><span class="token punctuation">:</span> <span class="token punctuation">{</span><span class="token punctuation">{</span> .Values.favorite.drink <span class="token punctuation">|</span> default "tea" <span class="token punctuation">|</span> quote <span class="token punctuation">}</span><span class="token punctuation">}</span>  <span class="token key atrule">food</span><span class="token punctuation">:</span> <span class="token punctuation">{</span><span class="token punctuation">{</span> .Values.favorite.food <span class="token punctuation">|</span> upper <span class="token punctuation">|</span> quote <span class="token punctuation">}</span><span class="token punctuation">}</span>  <span class="token punctuation">{</span><span class="token punctuation">{</span> if eq .Values.favorite.drink "coffee" <span class="token punctuation">}</span><span class="token punctuation">}</span>mug<span class="token punctuation">:</span> true<span class="token punctuation">{</span><span class="token punctuation">{</span> end <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>输出</strong></p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> v1<span class="token key atrule">kind</span><span class="token punctuation">:</span> ConfigMap<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">name</span><span class="token punctuation">:</span> eyewitness<span class="token punctuation">-</span>elk<span class="token punctuation">-</span>configmap<span class="token key atrule">data</span><span class="token punctuation">:</span>  <span class="token key atrule">myvalue</span><span class="token punctuation">:</span> <span class="token string">"Hello World"</span>  <span class="token key atrule">drink</span><span class="token punctuation">:</span> <span class="token string">"coffee"</span>  <span class="token key atrule">food</span><span class="token punctuation">:</span> <span class="token string">"PIZZA"</span>  <span class="token key atrule">mug</span><span class="token punctuation">:</span> <span class="token boolean important">true</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="with"><a href="#with" class="headerlink" title="with"></a>with</h3><p>with 控制变量作用域。. 是对当前范围的引用，而 .Values 告诉模板 Values 在当前范围内查找对象。</p><p>with 的语法类似于一个简单的 if 语句：</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token punctuation">{</span><span class="token punctuation">{</span> with PIPELINE <span class="token punctuation">}</span><span class="token punctuation">}</span>  <span class="token comment"># restricted scope</span><span class="token punctuation">{</span><span class="token punctuation">{</span> end <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>with 可以将当前范围 . 设置为特定对象：</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> v1<span class="token key atrule">kind</span><span class="token punctuation">:</span> ConfigMap<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">name</span><span class="token punctuation">:</span> <span class="token punctuation">{</span><span class="token punctuation">{</span> .Release.Name <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">-</span>configmap<span class="token key atrule">data</span><span class="token punctuation">:</span>  <span class="token key atrule">myvalue</span><span class="token punctuation">:</span> <span class="token string">"Hello World"</span>  <span class="token punctuation">{</span><span class="token punctuation">{</span><span class="token punctuation">-</span> with .Values.favorite <span class="token punctuation">}</span><span class="token punctuation">}</span>  <span class="token key atrule">drink</span><span class="token punctuation">:</span> <span class="token punctuation">{</span><span class="token punctuation">{</span> .drink <span class="token punctuation">|</span> default "tea" <span class="token punctuation">|</span> quote <span class="token punctuation">}</span><span class="token punctuation">}</span>  <span class="token key atrule">food</span><span class="token punctuation">:</span> <span class="token punctuation">{</span><span class="token punctuation">{</span> .food <span class="token punctuation">|</span> upper <span class="token punctuation">|</span> quote <span class="token punctuation">}</span><span class="token punctuation">}</span>  <span class="token punctuation">{</span><span class="token punctuation">{</span><span class="token punctuation">-</span> end <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>但是需要注意，在受限范围内，将无法使用 . 从父 chart 范围访问其他对象：</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token punctuation">{</span><span class="token punctuation">{</span><span class="token punctuation">-</span> with .Values.favorite <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token key atrule">drink</span><span class="token punctuation">:</span> <span class="token punctuation">{</span><span class="token punctuation">{</span> .drink <span class="token punctuation">|</span> default "tea" <span class="token punctuation">|</span> quote <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token key atrule">food</span><span class="token punctuation">:</span> <span class="token punctuation">{</span><span class="token punctuation">{</span> .food <span class="token punctuation">|</span> upper <span class="token punctuation">|</span> quote <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token key atrule">release</span><span class="token punctuation">:</span> <span class="token punctuation">{</span><span class="token punctuation">{</span> .Release.Name <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">{</span><span class="token punctuation">{</span><span class="token punctuation">-</span> end <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>由于 Release.Name 不在 . 的限制范围内，因此会报错。但是可以使用 重置作用域：</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token punctuation">{</span><span class="token punctuation">{</span><span class="token punctuation">-</span> with .Values.favorite <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token key atrule">drink</span><span class="token punctuation">:</span> <span class="token punctuation">{</span><span class="token punctuation">{</span> .drink <span class="token punctuation">|</span> default "tea" <span class="token punctuation">|</span> quote <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token key atrule">food</span><span class="token punctuation">:</span> <span class="token punctuation">{</span><span class="token punctuation">{</span> .food <span class="token punctuation">|</span> upper <span class="token punctuation">|</span> quote <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">{</span><span class="token punctuation">{</span><span class="token punctuation">-</span> end <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token key atrule">release</span><span class="token punctuation">:</span> <span class="token punctuation">{</span><span class="token punctuation">{</span> .Release.Name <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>还可以用 $ 从父 chart 范围访问对象 Release.name。模板执行开始时将 $ 映射到根作用域，并且在模板执行期间不会更改。以下内容也可以工作：</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token punctuation">{</span><span class="token punctuation">{</span><span class="token punctuation">-</span> with .Values.favorite <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token key atrule">drink</span><span class="token punctuation">:</span> <span class="token punctuation">{</span><span class="token punctuation">{</span> .drink <span class="token punctuation">|</span> default "tea" <span class="token punctuation">|</span> quote <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token key atrule">food</span><span class="token punctuation">:</span> <span class="token punctuation">{</span><span class="token punctuation">{</span> .food <span class="token punctuation">|</span> upper <span class="token punctuation">|</span> quote <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token key atrule">release</span><span class="token punctuation">:</span> <span class="token punctuation">{</span><span class="token punctuation">{</span> $.Release.Name <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">{</span><span class="token punctuation">{</span><span class="token punctuation">-</span> end <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="range"><a href="#range" class="headerlink" title="range"></a>range</h3><p>在 helm 的模板语言中，迭代集合的方法是使用 range 运算符。</p><p>示例：</p><p>values.yaml</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">favorite</span><span class="token punctuation">:</span>  <span class="token key atrule">drink</span><span class="token punctuation">:</span> coffee  <span class="token key atrule">food</span><span class="token punctuation">:</span> pizza<span class="token key atrule">pizzaToppings</span><span class="token punctuation">:</span>  <span class="token punctuation">-</span> mushrooms  <span class="token punctuation">-</span> cheese  <span class="token punctuation">-</span> peppers  <span class="token punctuation">-</span> onions<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> v1<span class="token key atrule">kind</span><span class="token punctuation">:</span> ConfigMap<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">name</span><span class="token punctuation">:</span> <span class="token punctuation">{</span><span class="token punctuation">{</span> .Release.Name <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">-</span>configmap<span class="token key atrule">data</span><span class="token punctuation">:</span>  <span class="token key atrule">myvalue</span><span class="token punctuation">:</span> <span class="token string">"Hello World"</span>  <span class="token punctuation">{</span><span class="token punctuation">{</span><span class="token punctuation">-</span> with .Values.favorite <span class="token punctuation">}</span><span class="token punctuation">}</span>  <span class="token key atrule">drink</span><span class="token punctuation">:</span> <span class="token punctuation">{</span><span class="token punctuation">{</span> .drink <span class="token punctuation">|</span> default "tea" <span class="token punctuation">|</span> quote <span class="token punctuation">}</span><span class="token punctuation">}</span>  <span class="token key atrule">food</span><span class="token punctuation">:</span> <span class="token punctuation">{</span><span class="token punctuation">{</span> .food <span class="token punctuation">|</span> upper <span class="token punctuation">|</span> quote <span class="token punctuation">}</span><span class="token punctuation">}</span>  <span class="token punctuation">{</span><span class="token punctuation">{</span><span class="token punctuation">-</span> end <span class="token punctuation">}</span><span class="token punctuation">}</span>  <span class="token key atrule">toppings</span><span class="token punctuation">:</span> <span class="token punctuation">|</span><span class="token punctuation">-</span>    <span class="token punctuation">{</span><span class="token punctuation">{</span><span class="token punctuation">-</span> range .Values.pizzaToppings <span class="token punctuation">}</span><span class="token punctuation">}</span>    <span class="token punctuation">-</span> <span class="token punctuation">{</span><span class="token punctuation">{</span> . <span class="token punctuation">|</span> title <span class="token punctuation">|</span> quote <span class="token punctuation">}</span><span class="token punctuation">}</span>    <span class="token punctuation">{</span><span class="token punctuation">{</span><span class="token punctuation">-</span> end <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>以下内容也可以工作：</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> v1<span class="token key atrule">kind</span><span class="token punctuation">:</span> ConfigMap<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">name</span><span class="token punctuation">:</span> <span class="token punctuation">{</span><span class="token punctuation">{</span> .Release.Name <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">-</span>configmap<span class="token key atrule">data</span><span class="token punctuation">:</span>  <span class="token key atrule">myvalue</span><span class="token punctuation">:</span> <span class="token string">"Hello World"</span>  <span class="token punctuation">{</span><span class="token punctuation">{</span><span class="token punctuation">-</span> with .Values.favorite <span class="token punctuation">}</span><span class="token punctuation">}</span>  <span class="token key atrule">drink</span><span class="token punctuation">:</span> <span class="token punctuation">{</span><span class="token punctuation">{</span> .drink <span class="token punctuation">|</span> default "tea" <span class="token punctuation">|</span> quote <span class="token punctuation">}</span><span class="token punctuation">}</span>  <span class="token key atrule">food</span><span class="token punctuation">:</span> <span class="token punctuation">{</span><span class="token punctuation">{</span> .food <span class="token punctuation">|</span> upper <span class="token punctuation">|</span> quote <span class="token punctuation">}</span><span class="token punctuation">}</span>  <span class="token key atrule">toppings</span><span class="token punctuation">:</span> <span class="token punctuation">|</span><span class="token punctuation">-</span>    <span class="token punctuation">{</span><span class="token punctuation">{</span><span class="token punctuation">-</span> range $.Values.pizzaToppings <span class="token punctuation">}</span><span class="token punctuation">}</span>    <span class="token punctuation">-</span> <span class="token punctuation">{</span><span class="token punctuation">{</span> . <span class="token punctuation">|</span> title <span class="token punctuation">|</span> quote <span class="token punctuation">}</span><span class="token punctuation">}</span>    <span class="token punctuation">{</span><span class="token punctuation">{</span><span class="token punctuation">-</span> end <span class="token punctuation">}</span><span class="token punctuation">}</span>  <span class="token punctuation">{</span><span class="token punctuation">{</span><span class="token punctuation">-</span> end <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>输出</strong></p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> v1<span class="token key atrule">kind</span><span class="token punctuation">:</span> ConfigMap<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">name</span><span class="token punctuation">:</span> edgy<span class="token punctuation">-</span>dragonfly<span class="token punctuation">-</span>configmap<span class="token key atrule">data</span><span class="token punctuation">:</span>  <span class="token key atrule">myvalue</span><span class="token punctuation">:</span> <span class="token string">"Hello World"</span>  <span class="token key atrule">drink</span><span class="token punctuation">:</span> <span class="token string">"coffee"</span>  <span class="token key atrule">food</span><span class="token punctuation">:</span> <span class="token string">"PIZZA"</span>  <span class="token key atrule">toppings</span><span class="token punctuation">:</span> <span class="token punctuation">|</span><span class="token punctuation">-</span>    <span class="token punctuation">-</span> <span class="token string">"Mushrooms"</span>    <span class="token punctuation">-</span> <span class="token string">"Cheese"</span>    <span class="token punctuation">-</span> <span class="token string">"Peppers"</span>    <span class="token punctuation">-</span> <span class="token string">"Onions"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><p>在 helm 模板中，变量是对另一个对象的命名引用。它遵循以下形式：<code>$name</code>，变量使用特殊的赋值运算符<code>:=</code>。</p><p>在前面的示例中，此代码会失败：</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token punctuation">{</span><span class="token punctuation">{</span><span class="token punctuation">-</span> with .Values.favorite <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token key atrule">drink</span><span class="token punctuation">:</span> <span class="token punctuation">{</span><span class="token punctuation">{</span> .drink <span class="token punctuation">|</span> default "tea" <span class="token punctuation">|</span> quote <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token key atrule">food</span><span class="token punctuation">:</span> <span class="token punctuation">{</span><span class="token punctuation">{</span> .food <span class="token punctuation">|</span> upper <span class="token punctuation">|</span> quote <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token key atrule">release</span><span class="token punctuation">:</span> <span class="token punctuation">{</span><span class="token punctuation">{</span> .Release.Name <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">{</span><span class="token punctuation">{</span><span class="token punctuation">-</span> end <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Release.Name 不在该代码 with 块限制的范围之内。可以将上面代码重写为对变量使用 Release.Name：</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> v1<span class="token key atrule">kind</span><span class="token punctuation">:</span> ConfigMap<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">name</span><span class="token punctuation">:</span> <span class="token punctuation">{</span><span class="token punctuation">{</span> .Release.Name <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">-</span>configmap<span class="token key atrule">data</span><span class="token punctuation">:</span>  <span class="token key atrule">myvalue</span><span class="token punctuation">:</span> <span class="token string">"Hello World"</span>  <span class="token punctuation">{</span><span class="token punctuation">{</span><span class="token punctuation">-</span> $relname <span class="token punctuation">:</span>= .Release.Name <span class="token punctuation">-</span><span class="token punctuation">}</span><span class="token punctuation">}</span>  <span class="token punctuation">{</span><span class="token punctuation">{</span><span class="token punctuation">-</span> with .Values.favorite <span class="token punctuation">}</span><span class="token punctuation">}</span>  <span class="token key atrule">drink</span><span class="token punctuation">:</span> <span class="token punctuation">{</span><span class="token punctuation">{</span> .drink <span class="token punctuation">|</span> default "tea" <span class="token punctuation">|</span> quote <span class="token punctuation">}</span><span class="token punctuation">}</span>  <span class="token key atrule">food</span><span class="token punctuation">:</span> <span class="token punctuation">{</span><span class="token punctuation">{</span> .food <span class="token punctuation">|</span> upper <span class="token punctuation">|</span> quote <span class="token punctuation">}</span><span class="token punctuation">}</span>  <span class="token key atrule">release</span><span class="token punctuation">:</span> <span class="token punctuation">{</span><span class="token punctuation">{</span> $relname <span class="token punctuation">}</span><span class="token punctuation">}</span>  <span class="token punctuation">{</span><span class="token punctuation">{</span><span class="token punctuation">-</span> end <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>输出</strong></p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> v1<span class="token key atrule">kind</span><span class="token punctuation">:</span> ConfigMap<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">name</span><span class="token punctuation">:</span> viable<span class="token punctuation">-</span>badger<span class="token punctuation">-</span>configmap<span class="token key atrule">data</span><span class="token punctuation">:</span>  <span class="token key atrule">myvalue</span><span class="token punctuation">:</span> <span class="token string">"Hello World"</span>  <span class="token key atrule">drink</span><span class="token punctuation">:</span> <span class="token string">"coffee"</span>  <span class="token key atrule">food</span><span class="token punctuation">:</span> <span class="token string">"PIZZA"</span>  <span class="token key atrule">release</span><span class="token punctuation">:</span> viable<span class="token punctuation">-</span>badger<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>变量在 range 循环中特别有用。它们可以用于类似列表的对象，以同时捕获索引和值：</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">toppings</span><span class="token punctuation">:</span> <span class="token punctuation">|</span><span class="token punctuation">-</span>  <span class="token punctuation">{</span><span class="token punctuation">{</span><span class="token punctuation">-</span> range $index<span class="token punctuation">,</span> $topping <span class="token punctuation">:</span>= .Values.pizzaToppings <span class="token punctuation">}</span><span class="token punctuation">}</span>    <span class="token punctuation">{</span><span class="token punctuation">{</span> $index <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">:</span> <span class="token punctuation">{</span><span class="token punctuation">{</span> $topping <span class="token punctuation">}</span><span class="token punctuation">}</span>  <span class="token punctuation">{</span><span class="token punctuation">{</span><span class="token punctuation">-</span> end <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>注意，range 首先跟的是变量，然后是赋值运算符，然后是列表。这会将整数索引（从零开始）分配给 <code>$index</code>，并将值分配给<code>$topping</code>。</p><p><strong>输出</strong></p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">toppings</span><span class="token punctuation">:</span> <span class="token punctuation">|</span><span class="token punctuation">-</span>  <span class="token key atrule">0</span><span class="token punctuation">:</span> mushrooms  <span class="token key atrule">1</span><span class="token punctuation">:</span> cheese  <span class="token key atrule">2</span><span class="token punctuation">:</span> peppers  <span class="token key atrule">3</span><span class="token punctuation">:</span> onions<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>对于同时具有键和值的数据结构，可以使用 range 两者来获取。</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> v1<span class="token key atrule">kind</span><span class="token punctuation">:</span> ConfigMap<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">name</span><span class="token punctuation">:</span> <span class="token punctuation">{</span><span class="token punctuation">{</span> .Release.Name <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">-</span>configmap<span class="token key atrule">data</span><span class="token punctuation">:</span>  <span class="token key atrule">myvalue</span><span class="token punctuation">:</span> <span class="token string">"Hello World"</span>  <span class="token punctuation">{</span><span class="token punctuation">{</span><span class="token punctuation">-</span> range $key<span class="token punctuation">,</span> $val <span class="token punctuation">:</span>= .Values.favorite <span class="token punctuation">}</span><span class="token punctuation">}</span>  <span class="token punctuation">{</span><span class="token punctuation">{</span> $key <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">:</span> <span class="token punctuation">{</span><span class="token punctuation">{</span> $val <span class="token punctuation">|</span> quote <span class="token punctuation">}</span><span class="token punctuation">}</span>  <span class="token punctuation">{</span><span class="token punctuation">{</span><span class="token punctuation">-</span> end <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>输出</strong></p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> v1<span class="token key atrule">kind</span><span class="token punctuation">:</span> ConfigMap<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">name</span><span class="token punctuation">:</span> eager<span class="token punctuation">-</span>rabbit<span class="token punctuation">-</span>configmap<span class="token key atrule">data</span><span class="token punctuation">:</span>  <span class="token key atrule">myvalue</span><span class="token punctuation">:</span> <span class="token string">"Hello World"</span>  <span class="token key atrule">drink</span><span class="token punctuation">:</span> <span class="token string">"coffee"</span>  <span class="token key atrule">food</span><span class="token punctuation">:</span> <span class="token string">"pizza"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>变量通常不是“全局”的，它们的作用域仅限于声明它们的块。$ 变量是全局变量，该变量始终指向根上下文。</p><h2 id="命名模板"><a href="#命名模板" class="headerlink" title="命名模板"></a>命名模板</h2><p>命名模板也称为部分模板或子模板，是一个简单的文件中定义的、并且给定名称的模板。_helpers.tpl 文件是命名模板的默认位置。</p><p>命名模板需要注意的是，模板名称是全局的，如果声明了两个相同名称的模板，则以最后加载的那个为准。</p><p>通常的命名约定是在每个定义的模板前添加 chart 名称：<code>{{ define "mychart.labels" }}</code>。通过使用特定的 chart 名称作为前缀，可以避免由于模板名称相同而引起的任何冲突。</p><h3 id="define"><a href="#define" class="headerlink" title="define"></a>define</h3><p>define 操作可以在模板文件内部创建命名模板，语法如下：</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token punctuation">{</span><span class="token punctuation">{</span> define "MY.NAME" <span class="token punctuation">}</span><span class="token punctuation">}</span>  <span class="token comment"># body of template here</span><span class="token punctuation">{</span><span class="token punctuation">{</span> end <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>定义一个模板来封装 Kubernetes 标签块，示例：</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token punctuation">{</span><span class="token punctuation">{</span><span class="token punctuation">-</span> define "mychart.labels" <span class="token punctuation">}</span><span class="token punctuation">}</span>  <span class="token key atrule">labels</span><span class="token punctuation">:</span>    <span class="token key atrule">generator</span><span class="token punctuation">:</span> helm    <span class="token key atrule">date</span><span class="token punctuation">:</span> <span class="token punctuation">{</span><span class="token punctuation">{</span> now <span class="token punctuation">|</span> htmlDate <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">{</span><span class="token punctuation">{</span><span class="token punctuation">-</span> end <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>将此模板嵌入到现有的 ConfigMap 中，然后将其包含在 template 操作中：</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token punctuation">{</span><span class="token punctuation">{</span><span class="token punctuation">-</span> define "mychart.labels" <span class="token punctuation">}</span><span class="token punctuation">}</span>  <span class="token key atrule">labels</span><span class="token punctuation">:</span>    <span class="token key atrule">generator</span><span class="token punctuation">:</span> helm    <span class="token key atrule">date</span><span class="token punctuation">:</span> <span class="token punctuation">{</span><span class="token punctuation">{</span> now <span class="token punctuation">|</span> htmlDate <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">{</span><span class="token punctuation">{</span><span class="token punctuation">-</span> end <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> v1<span class="token key atrule">kind</span><span class="token punctuation">:</span> ConfigMap<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">name</span><span class="token punctuation">:</span> <span class="token punctuation">{</span><span class="token punctuation">{</span> .Release.Name <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">-</span>configmap  <span class="token punctuation">{</span><span class="token punctuation">{</span><span class="token punctuation">-</span> template "mychart.labels" <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token key atrule">data</span><span class="token punctuation">:</span>  <span class="token key atrule">myvalue</span><span class="token punctuation">:</span> <span class="token string">"Hello World"</span>  <span class="token punctuation">{</span><span class="token punctuation">{</span><span class="token punctuation">-</span> range $key<span class="token punctuation">,</span> $val <span class="token punctuation">:</span>= .Values.favorite <span class="token punctuation">}</span><span class="token punctuation">}</span>  <span class="token punctuation">{</span><span class="token punctuation">{</span> $key <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">:</span> <span class="token punctuation">{</span><span class="token punctuation">{</span> $val <span class="token punctuation">|</span> quote <span class="token punctuation">}</span><span class="token punctuation">}</span>  <span class="token punctuation">{</span><span class="token punctuation">{</span><span class="token punctuation">-</span> end <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>输出</strong></p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> v1<span class="token key atrule">kind</span><span class="token punctuation">:</span> ConfigMap<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">name</span><span class="token punctuation">:</span> running<span class="token punctuation">-</span>panda<span class="token punctuation">-</span>configmap  <span class="token key atrule">labels</span><span class="token punctuation">:</span>    <span class="token key atrule">generator</span><span class="token punctuation">:</span> helm    <span class="token key atrule">date</span><span class="token punctuation">:</span> <span class="token datetime number">2016-11-02</span><span class="token key atrule">data</span><span class="token punctuation">:</span>  <span class="token key atrule">myvalue</span><span class="token punctuation">:</span> <span class="token string">"Hello World"</span>  <span class="token key atrule">drink</span><span class="token punctuation">:</span> <span class="token string">"coffee"</span>  <span class="token key atrule">food</span><span class="token punctuation">:</span> <span class="token string">"pizza"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>helm chart 通常将这些模板放在 _helpers.tpl 文件中，然后可以在 ConfigMap 中调用：</p><p>_helpers.tpl</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token punctuation">{</span><span class="token punctuation">{</span>/* Generate basic labels <span class="token important">*/</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">{</span><span class="token punctuation">{</span><span class="token punctuation">-</span> define "mychart.labels" <span class="token punctuation">}</span><span class="token punctuation">}</span>  <span class="token key atrule">labels</span><span class="token punctuation">:</span>    <span class="token key atrule">generator</span><span class="token punctuation">:</span> helm    <span class="token key atrule">date</span><span class="token punctuation">:</span> <span class="token punctuation">{</span><span class="token punctuation">{</span> now <span class="token punctuation">|</span> htmlDate <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">{</span><span class="token punctuation">{</span><span class="token punctuation">-</span> end <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> v1<span class="token key atrule">kind</span><span class="token punctuation">:</span> ConfigMap<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">name</span><span class="token punctuation">:</span> <span class="token punctuation">{</span><span class="token punctuation">{</span> .Release.Name <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">-</span>configmap  <span class="token punctuation">{</span><span class="token punctuation">{</span><span class="token punctuation">-</span> template "mychart.labels" <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token key atrule">data</span><span class="token punctuation">:</span>  <span class="token key atrule">myvalue</span><span class="token punctuation">:</span> <span class="token string">"Hello World"</span>  <span class="token punctuation">{</span><span class="token punctuation">{</span><span class="token punctuation">-</span> range $key<span class="token punctuation">,</span> $val <span class="token punctuation">:</span>= .Values.favorite <span class="token punctuation">}</span><span class="token punctuation">}</span>  <span class="token punctuation">{</span><span class="token punctuation">{</span> $key <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">:</span> <span class="token punctuation">{</span><span class="token punctuation">{</span> $val <span class="token punctuation">|</span> quote <span class="token punctuation">}</span><span class="token punctuation">}</span>  <span class="token punctuation">{</span><span class="token punctuation">{</span><span class="token punctuation">-</span> end <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>模板范围</strong><br>_helpers.tpl</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token punctuation">{</span><span class="token punctuation">{</span>/* Generate basic labels <span class="token important">*/</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">{</span><span class="token punctuation">{</span><span class="token punctuation">-</span> define "mychart.labels" <span class="token punctuation">}</span><span class="token punctuation">}</span>  <span class="token key atrule">labels</span><span class="token punctuation">:</span>    <span class="token key atrule">generator</span><span class="token punctuation">:</span> helm    <span class="token key atrule">date</span><span class="token punctuation">:</span> <span class="token punctuation">{</span><span class="token punctuation">{</span> now <span class="token punctuation">|</span> htmlDate <span class="token punctuation">}</span><span class="token punctuation">}</span>    <span class="token key atrule">chart</span><span class="token punctuation">:</span> <span class="token punctuation">{</span><span class="token punctuation">{</span> .Chart.Name <span class="token punctuation">}</span><span class="token punctuation">}</span>    <span class="token key atrule">version</span><span class="token punctuation">:</span> <span class="token punctuation">{</span><span class="token punctuation">{</span> .Chart.Version <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">{</span><span class="token punctuation">{</span><span class="token punctuation">-</span> end <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> v1<span class="token key atrule">kind</span><span class="token punctuation">:</span> ConfigMap<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">name</span><span class="token punctuation">:</span> <span class="token punctuation">{</span><span class="token punctuation">{</span> .Release.Name <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">-</span>configmap  <span class="token punctuation">{</span><span class="token punctuation">{</span><span class="token punctuation">-</span> template "mychart.labels" . <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">helm install --dry-run --debug plinking-anaco ./mychart<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>输出：</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> v1<span class="token key atrule">kind</span><span class="token punctuation">:</span> ConfigMap<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">name</span><span class="token punctuation">:</span> plinking<span class="token punctuation">-</span>anaco<span class="token punctuation">-</span>configmap  <span class="token key atrule">labels</span><span class="token punctuation">:</span>    <span class="token key atrule">generator</span><span class="token punctuation">:</span> helm    <span class="token key atrule">date</span><span class="token punctuation">:</span> <span class="token datetime number">2016-11-02</span>    <span class="token key atrule">chart</span><span class="token punctuation">:</span> mychart    <span class="token key atrule">version</span><span class="token punctuation">:</span> 0.1.0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>当命名模板（使用 define 创建的模板）被渲染时，它将接收 template 调用传递的范围。</p><h3 id="include-函数"><a href="#include-函数" class="headerlink" title="include 函数"></a>include 函数</h3><p>示例：</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token punctuation">{</span><span class="token punctuation">{</span><span class="token punctuation">-</span> define "mychart.app" <span class="token punctuation">-</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token key atrule">app_name</span><span class="token punctuation">:</span> <span class="token punctuation">{</span><span class="token punctuation">{</span> .Chart.Name <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token key atrule">app_version</span><span class="token punctuation">:</span> <span class="token string">"{{ .Chart.Version }}"</span><span class="token punctuation">{</span><span class="token punctuation">{</span><span class="token punctuation">-</span> end <span class="token punctuation">-</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> v1<span class="token key atrule">kind</span><span class="token punctuation">:</span> ConfigMap<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">name</span><span class="token punctuation">:</span> <span class="token punctuation">{</span><span class="token punctuation">{</span> .Release.Name <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">-</span>configmap  <span class="token key atrule">labels</span><span class="token punctuation">:</span>    <span class="token punctuation">{</span><span class="token punctuation">{</span> template "mychart.app" . <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token key atrule">data</span><span class="token punctuation">:</span>  <span class="token key atrule">myvalue</span><span class="token punctuation">:</span> <span class="token string">"Hello World"</span>  <span class="token punctuation">{</span><span class="token punctuation">{</span><span class="token punctuation">-</span> range $key<span class="token punctuation">,</span> $val <span class="token punctuation">:</span>= .Values.favorite <span class="token punctuation">}</span><span class="token punctuation">}</span>  <span class="token punctuation">{</span><span class="token punctuation">{</span> $key <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">:</span> <span class="token punctuation">{</span><span class="token punctuation">{</span> $val <span class="token punctuation">|</span> quote <span class="token punctuation">}</span><span class="token punctuation">}</span>  <span class="token punctuation">{</span><span class="token punctuation">{</span><span class="token punctuation">-</span> end <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">{</span><span class="token punctuation">{</span> template "mychart.app" . <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>输出：</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> v1<span class="token key atrule">kind</span><span class="token punctuation">:</span> ConfigMap<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">name</span><span class="token punctuation">:</span> measly<span class="token punctuation">-</span>whippet<span class="token punctuation">-</span>configmap  <span class="token key atrule">labels</span><span class="token punctuation">:</span>    <span class="token key atrule">app_name</span><span class="token punctuation">:</span> mychart<span class="token key atrule">app_version</span><span class="token punctuation">:</span> <span class="token string">"0.1.0+1478129847"</span><span class="token key atrule">data</span><span class="token punctuation">:</span>  <span class="token key atrule">myvalue</span><span class="token punctuation">:</span> <span class="token string">"Hello World"</span>  <span class="token key atrule">drink</span><span class="token punctuation">:</span> <span class="token string">"coffee"</span>  <span class="token key atrule">food</span><span class="token punctuation">:</span> <span class="token string">"pizza"</span>  <span class="token key atrule">app_name</span><span class="token punctuation">:</span> mychart<span class="token key atrule">app_version</span><span class="token punctuation">:</span> <span class="token string">"0.1.0+1478129847"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看到，app_version 的缩进是错误的，因为 template 是操作而不是函数，所以无法将 template 调用的输出传递给其他函数。</p><p>helm 提供了一种替代方法，include 可以将模板的内容导入到当前 pipeline 中，然后可以将其传递给 pipeline 中的其它函数。</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> v1<span class="token key atrule">kind</span><span class="token punctuation">:</span> ConfigMap<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">name</span><span class="token punctuation">:</span> <span class="token punctuation">{</span><span class="token punctuation">{</span> .Release.Name <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">-</span>configmap  <span class="token key atrule">labels</span><span class="token punctuation">:</span><span class="token punctuation">{</span><span class="token punctuation">{</span> include "mychart.app" . <span class="token punctuation">|</span> indent 4 <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token key atrule">data</span><span class="token punctuation">:</span>  <span class="token key atrule">myvalue</span><span class="token punctuation">:</span> <span class="token string">"Hello World"</span>  <span class="token punctuation">{</span><span class="token punctuation">{</span><span class="token punctuation">-</span> range $key<span class="token punctuation">,</span> $val <span class="token punctuation">:</span>= .Values.favorite <span class="token punctuation">}</span><span class="token punctuation">}</span>  <span class="token punctuation">{</span><span class="token punctuation">{</span> $key <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">:</span> <span class="token punctuation">{</span><span class="token punctuation">{</span> $val <span class="token punctuation">|</span> quote <span class="token punctuation">}</span><span class="token punctuation">}</span>  <span class="token punctuation">{</span><span class="token punctuation">{</span><span class="token punctuation">-</span> end <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">{</span><span class="token punctuation">{</span> include "mychart.app" . <span class="token punctuation">|</span> indent 2 <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> v1<span class="token key atrule">kind</span><span class="token punctuation">:</span> ConfigMap<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">name</span><span class="token punctuation">:</span> edgy<span class="token punctuation">-</span>mole<span class="token punctuation">-</span>configmap  <span class="token key atrule">labels</span><span class="token punctuation">:</span>    <span class="token key atrule">app_name</span><span class="token punctuation">:</span> mychart    <span class="token key atrule">app_version</span><span class="token punctuation">:</span> <span class="token string">"0.1.0+1478129987"</span><span class="token key atrule">data</span><span class="token punctuation">:</span>  <span class="token key atrule">myvalue</span><span class="token punctuation">:</span> <span class="token string">"Hello World"</span>  <span class="token key atrule">drink</span><span class="token punctuation">:</span> <span class="token string">"coffee"</span>  <span class="token key atrule">food</span><span class="token punctuation">:</span> <span class="token string">"pizza"</span>  <span class="token key atrule">app_name</span><span class="token punctuation">:</span> mychart  <span class="token key atrule">app_version</span><span class="token punctuation">:</span> <span class="token string">"0.1.0+1478129987"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="访问模板内的文件"><a href="#访问模板内的文件" class="headerlink" title="访问模板内的文件"></a>访问模板内的文件</h2><p>有时要导入文件，而不是模板，可以通过 .Files 描述的对象访问文件来实现。</p><p>helm 提供了通过 .Files 对象访问文件的权限。有几点需要注意：</p><ol><li>在 chart 中可以添加其他文件。但由于 Kubernetes 对象的存储限制，chart 必须小于 1M</li><li>.Files 因为安全原因，某些文件无法通过该对象访问：<ul><li>无法访问 templates/ 中的文件</li><li>无法访问使用 .helmignore 排除的文件</li></ul></li><li>chart 不保留 unix 模式信息，因此文件级权限限制对 .Files 对象的文件可用性没有影响</li></ol><p>示例：<br>编写一个模板，将三个文件读入 ConfigMap。首先向 chart 添加三个文件，将三个文件放入 mychart/ 目录中。</p><p>config1.toml</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">message = Hello from config 1<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>config1.toml</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">message = Hello from config 2<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>config3.toml</p><pre class="line-numbers language-shell" data-language="shell"><div class="caption"><span>/ yaml</span></div><code class="language-shell">message = Hello from config 3<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>使用 range 函数来遍历它们，并将其内容注入到 ConfigMap 中：</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> v1<span class="token key atrule">kind</span><span class="token punctuation">:</span> ConfigMap<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">name</span><span class="token punctuation">:</span> <span class="token punctuation">{</span><span class="token punctuation">{</span> .Release.Name <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">-</span>configmap<span class="token key atrule">data</span><span class="token punctuation">:</span>  <span class="token punctuation">{</span><span class="token punctuation">{</span><span class="token punctuation">-</span> $files <span class="token punctuation">:</span>= .Files <span class="token punctuation">}</span><span class="token punctuation">}</span>  <span class="token punctuation">{</span><span class="token punctuation">{</span><span class="token punctuation">-</span> range tuple "config1.toml" "config2.toml" "config3.toml" <span class="token punctuation">}</span><span class="token punctuation">}</span>  <span class="token punctuation">{</span><span class="token punctuation">{</span> . <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">:</span> <span class="token punctuation">|</span><span class="token punctuation">-</span>    <span class="token punctuation">{</span><span class="token punctuation">{</span> $files.Get . <span class="token punctuation">}</span><span class="token punctuation">}</span>  <span class="token punctuation">{</span><span class="token punctuation">{</span><span class="token punctuation">-</span> end <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>输出：</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> v1<span class="token key atrule">kind</span><span class="token punctuation">:</span> ConfigMap<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">name</span><span class="token punctuation">:</span> quieting<span class="token punctuation">-</span>giraf<span class="token punctuation">-</span>configmap<span class="token key atrule">data</span><span class="token punctuation">:</span>  <span class="token key atrule">config1.toml</span><span class="token punctuation">:</span> <span class="token punctuation">|</span><span class="token punctuation">-</span>    message = Hello from config 1  <span class="token key atrule">config2.toml</span><span class="token punctuation">:</span> <span class="token punctuation">|</span><span class="token punctuation">-</span>    message = This is config 2  <span class="token key atrule">config3.toml</span><span class="token punctuation">:</span> <span class="token punctuation">|</span><span class="token punctuation">-</span>    message = Goodbye from config 3<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="文件路径处理"><a href="#文件路径处理" class="headerlink" title="文件路径处理"></a>文件路径处理</h3><p>在处理文件时，对文件路径本身执行一些标准操作会非常有用。相关函数有：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">base        返回路径的最后一个元素dir         返回目录，去除路径的最后一部分clean       清理路径，只保留路径开头和结尾ext         返回文件扩展名isAbs       检查文件路径是否是绝对路径<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="glob-模式"><a href="#glob-模式" class="headerlink" title="glob 模式"></a>glob 模式</h3><p>随着 chart 的增长，可能会更需要组织文件。helm 提供了 Files.Glob(pattern string) 方法，用来以 glob 模式灵活地提取某些文件。</p><p>例如，目录结构如下：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">foo/:  foo.txt foo.yamlbar/:  bar.go bar.conf baz.yaml<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>globs 有多种选择：</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token punctuation">{</span><span class="token punctuation">{</span> $currentScope <span class="token punctuation">:</span>= .<span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">{</span><span class="token punctuation">{</span> range $path<span class="token punctuation">,</span> $_ <span class="token punctuation">:</span>=  .Files.Glob  "<span class="token important">**.yaml"</span> <span class="token punctuation">}</span><span class="token punctuation">}</span>    <span class="token punctuation">{</span><span class="token punctuation">{</span><span class="token punctuation">-</span> with $currentScope<span class="token punctuation">}</span><span class="token punctuation">}</span>        <span class="token punctuation">{</span><span class="token punctuation">{</span> .Files.Get $path <span class="token punctuation">}</span><span class="token punctuation">}</span>    <span class="token punctuation">{</span><span class="token punctuation">{</span><span class="token punctuation">-</span> end <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">{</span><span class="token punctuation">{</span> end <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>或</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token punctuation">{</span><span class="token punctuation">{</span> range $path<span class="token punctuation">,</span> $_ <span class="token punctuation">:</span>=  .Files.Glob  "<span class="token important">**.yaml"</span> <span class="token punctuation">}</span><span class="token punctuation">}</span>      <span class="token punctuation">{</span><span class="token punctuation">{</span> $.Files.Get $path <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">{</span><span class="token punctuation">{</span> end <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="ConfigMap-和-Secrets-实用函数"><a href="#ConfigMap-和-Secrets-实用函数" class="headerlink" title="ConfigMap 和 Secrets 实用函数"></a>ConfigMap 和 Secrets 实用函数</h3><p>想要将文件内容同时放入 ConfigMap 和 Secrets 中，以便在运行时安装到 pod 中。</p><p>结合 glob 模式，从上面的 glob 示例给出目录结构：</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> v1<span class="token key atrule">kind</span><span class="token punctuation">:</span> ConfigMap<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">name</span><span class="token punctuation">:</span> conf<span class="token key atrule">data</span><span class="token punctuation">:</span><span class="token punctuation">{</span><span class="token punctuation">{</span> (.Files.Glob "foo/<span class="token important">*").AsConfig</span> <span class="token punctuation">|</span> indent 2 <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">---</span><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> v1<span class="token key atrule">kind</span><span class="token punctuation">:</span> Secret<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">name</span><span class="token punctuation">:</span> very<span class="token punctuation">-</span>secret<span class="token key atrule">type</span><span class="token punctuation">:</span> Opaque<span class="token key atrule">data</span><span class="token punctuation">:</span><span class="token punctuation">{</span><span class="token punctuation">{</span> (.Files.Glob "bar/<span class="token important">*").AsSecrets</span> <span class="token punctuation">|</span> indent 2 <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="编码方式"><a href="#编码方式" class="headerlink" title="编码方式"></a>编码方式</h3><p>可以导入文件并使用 base-64 模板对其进行编码，以确保成功传输：</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> v1<span class="token key atrule">kind</span><span class="token punctuation">:</span> Secret<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">name</span><span class="token punctuation">:</span> <span class="token punctuation">{</span><span class="token punctuation">{</span> .Release.Name <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">-</span>secret<span class="token key atrule">type</span><span class="token punctuation">:</span> Opaque<span class="token key atrule">data</span><span class="token punctuation">:</span>  <span class="token key atrule">token</span><span class="token punctuation">:</span> <span class="token punctuation">|</span><span class="token punctuation">-</span>    <span class="token punctuation">{</span><span class="token punctuation">{</span> .Files.Get "config1.toml" <span class="token punctuation">|</span> b64enc <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>输出：</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> v1<span class="token key atrule">kind</span><span class="token punctuation">:</span> Secret<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">name</span><span class="token punctuation">:</span> lucky<span class="token punctuation">-</span>turkey<span class="token punctuation">-</span>secret<span class="token key atrule">type</span><span class="token punctuation">:</span> Opaque<span class="token key atrule">data</span><span class="token punctuation">:</span>  <span class="token key atrule">token</span><span class="token punctuation">:</span> <span class="token punctuation">|</span><span class="token punctuation">-</span>    bWVzc2FnZSA9IEhlbGxvIGZyb20gY29uZmlnIDEK<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="Lines"><a href="#Lines" class="headerlink" title="Lines"></a>Lines</h3><p>有时，需要访问模板中文件的每一行。</p><p>为此 helm 提供了 Lines 方法，Lines 可以使用 range 函数循环遍历：</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">data</span><span class="token punctuation">:</span>  <span class="token key atrule">some-file.txt</span><span class="token punctuation">:</span> <span class="token punctuation">{</span><span class="token punctuation">{</span> range .Files.Lines "foo/bar.txt" <span class="token punctuation">}</span><span class="token punctuation">}</span>    <span class="token punctuation">{</span><span class="token punctuation">{</span> . <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">{</span><span class="token punctuation">{</span> end <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>在 helm install 期间，无法将外部文件传递给 chart。因此，必须使用 helm install -f 或 helm install –set 加载数据。</p><h2 id="子-chart-和全局-Values"><a href="#子-chart-和全局-Values" class="headerlink" title="子 chart 和全局 Values"></a>子 chart 和全局 Values</h2><p>chart 可以具有依赖项，称为子 chart，子 chart 也有自己的 values 和 templates。</p><p>关于子 chart，有几点主要注意：</p><ol><li>子 chart 被看作“独立的”，它不能显式依赖其父 chart，子 chart 无法访问其父 chart 的 values</li><li>父 chart 可以覆盖子 chart 的 values</li><li>helm 可以设置能被所有 chart 访问的全局 values</li></ol><h3 id="创建子-chart"><a href="#创建子-chart" class="headerlink" title="创建子 chart"></a>创建子 chart</h3><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">helm create mychartcd mychart/chartshelm create mysubchart<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>当子 chart 中 values 的 key 与父 chart 中 values 的 key 相同时，父 chart 的 values 会覆盖子 chart 的 values。</p><h3 id="全局-values"><a href="#全局-values" class="headerlink" title="全局 values"></a>全局 values</h3><p>全局 values 是可以从任何 chart 或子 chart 中以完全相同的名称访问的 values。全局 values 需要显式声明。</p><p>Values.global 可以用来设置全局 values，例如：</p><p>values.yaml</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">favorite</span><span class="token punctuation">:</span>  <span class="token key atrule">drink</span><span class="token punctuation">:</span> coffee  <span class="token key atrule">food</span><span class="token punctuation">:</span> pizza<span class="token key atrule">pizzaToppings</span><span class="token punctuation">:</span>  <span class="token punctuation">-</span> mushrooms  <span class="token punctuation">-</span> cheese  <span class="token punctuation">-</span> peppers  <span class="token punctuation">-</span> onions<span class="token key atrule">mysubchart</span><span class="token punctuation">:</span>  <span class="token key atrule">dessert</span><span class="token punctuation">:</span> ice cream<span class="token key atrule">global</span><span class="token punctuation">:</span>  <span class="token key atrule">salad</span><span class="token punctuation">:</span> caesar <span class="token comment">#全局values</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="共享模板"><a href="#共享模板" class="headerlink" title="共享模板"></a>共享模板</h3><p>父 chart 可以与子 chart 共享模板。任何 chart 中任何已定义的模板块都可以用于其它 chart。</p><p>定义一个简单的模板，例如：</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token punctuation">{</span><span class="token punctuation">{</span><span class="token punctuation">-</span> define "labels" <span class="token punctuation">}</span><span class="token punctuation">}</span>from<span class="token punctuation">:</span> mychart<span class="token punctuation">{</span><span class="token punctuation">{</span> end <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>include 和 template 函数都可以引用模板，但 include 可以动态引用，而 template 仅接受字符串。</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token punctuation">{</span> <span class="token punctuation">{</span> include $mytemplate <span class="token punctuation">}</span> <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="更多"><a href="#更多" class="headerlink" title="更多"></a>更多</h2><h3 id="helmignore-文件"><a href="#helmignore-文件" class="headerlink" title=".helmignore 文件"></a>.helmignore 文件</h3><p>.helmignore 文件用于指定不想包含在 helm chart 中的文件。</p><p>如果存在 .helmignore 文件，helm package 命令将忽略该文件中匹配到的所有文件。</p><p>.helmignore 文件支持 unix shell 全局匹配、相对路径匹配和否定（以 ! 前缀）。每行仅支持一种模式。</p><p>示例：</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token comment"># comment</span>.git<span class="token important">*/temp*</span><span class="token important">*/*/temp*</span>temp<span class="token punctuation">?</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h3><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml">helm lint                           验证chart是否遵循语法helm install <span class="token punctuation">-</span><span class="token punctuation">-</span>dry<span class="token punctuation">-</span>run <span class="token punctuation">-</span><span class="token punctuation">-</span>debug      渲染模板，然后返回生成的kubernetes清单文件helm template <span class="token punctuation">-</span><span class="token punctuation">-</span>debug               渲染模板，然后返回生成的kubernetes清单文件helm get manifest                   查看服务器上安装了哪些模板<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>当 yaml 无法解析、但想查看生成内容时，可以先在模板中注释掉问题部分，然后重新运行 helm install –dry-run –debug：</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> v2<span class="token comment"># some: problem section</span><span class="token comment"># {{ .Values.foo | quote }}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>上面的内容将渲染并返回完整的注释：</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> v2<span class="token comment"># some: problem section</span><span class="token comment">#  "bar"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 云原生 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Helm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>树莓派 问题排查</title>
      <link href="2021/03/24/shu-mei-pai-wen-ti-pai-cha/"/>
      <url>2021/03/24/shu-mei-pai-wen-ti-pai-cha/</url>
      
        <content type="html"><![CDATA[<h2 id="树莓派开机时无法自动开启网络"><a href="#树莓派开机时无法自动开启网络" class="headerlink" title="树莓派开机时无法自动开启网络"></a>树莓派开机时无法自动开启网络</h2><p>因为不知道是哪个相关的服务启动失败了，故执行<code>systemctl list-units</code> 命令查看所有启动过的unit。<br>发现dhcpcd 启动后报错退出，进而执行<code>systemctl status dhcpcd</code>查看原因。 发现程序报错：”dhcpcd route socket overflowed”<br>上网查找获得解决方法：<a href="https://www.raspberrypi.org/forums/viewtopic.php?f=28&amp;p=1712939">原文链接</a></p><p>问题原因如下：</p><pre class="line-numbers language-none"><code class="language-none">原文：Veth is a virtual Ethernet adapter, designed to be plugged in host network bridges, in general. Bridge members do not need any IP address configuration to work.When dhcpcd sees a new network device it tries to configure it. In the case of bridge members you have to specifically take action,so that dhcpcd leaves the interface alone.译文：Veth 是虚拟网络适配器，用来插入主机网桥。通常，网桥不需要配置IP地址就能工作。当dhcpcd 看到一个新的网桥的时候，会去配置它(然后配置失败就退出……)。 如果你是网桥成员的话，你必须采取特别行动，让dhcpcd离网桥远点。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 树莓派 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>文明、国家及其延伸</title>
      <link href="2021/03/14/wen-ming-guo-jia-ji-qi-yan-shen/"/>
      <url>2021/03/14/wen-ming-guo-jia-ji-qi-yan-shen/</url>
      
        <content type="html"><![CDATA[<ul><li><p><strong>文明：</strong>认同同一精神理念的民众组成的集体，其中理念可以是思想、文化、宗教。比如中华文明在思想和民族文化上的认同，美国文化的民主与自由，土耳其、伊朗的政教合一。</p></li><li><p><strong>国家：</strong> 由统治集团统治的区域。如政党、教皇、军政府</p></li><li><p><strong>国家合法性：</strong>    在国家发展过程中是否能满足国民的基本需求。</p></li><li><p><strong>民心：</strong> 引起民众产生共鸣的认可。</p></li><li><p><strong>民意：</strong> 引起民众产生共鸣的意志。</p></li><li><p>推动社会的本质：精英阶层需要与众不同的欲望，与民众想要追赶精英阶层的欲望</p></li><li><p>抛去上层，全世界的老百姓的诉求是否是一致的？即大家都希望日子越过越好?只不过中国是靠自身努力，欧美以前是靠殖民统治，现在是靠输出战争。</p></li><li><p>人类命运共同体：既然民众对美好生活的向往是一致的。即便各个国家的文化各不相同，但政府间可以相互学习相互比较，使全人类越过越好。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 想法 </category>
          
          <category> 世界观 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>读书</title>
      <link href="2021/03/14/yi-du-shu-dan/"/>
      <url>2021/03/14/yi-du-shu-dan/</url>
      
        <content type="html"><![CDATA[<h2 id="谋生"><a href="#谋生" class="headerlink" title="谋生"></a>谋生</h2><ul><li><p><strong>《图解HTTP》</strong> 2021/3/1-2021/3/13<br>一本讲述HTTP协议的书。与厚重的《HTTP 权威指南不同》，这本书我将其定义为<strong>HTTP扫盲</strong>书。书中夹杂着的大量的插图，看的时候不会那么枯燥。这本书我有一半页数是在健身房看的，正好打发时间。</p></li><li><p><strong>《Kubernetes 源码剖析》</strong> 2021/3/17-2021/5/3<br>本书会更加深入地了解Kubernetes底层运行机制，虽然做不到对底层了如指掌，但至少对K8s的上层运行机制等有很大帮助。</p></li><li><p><strong>《深入浅出 Istio》</strong> 2021/4/22-2021/5/18<br>本书介绍了Istio的原理、安装方式，以及各种应用场景。Istio 本身就是一个应用软件，还需要配合实践巩固。</p></li></ul><h2 id="谋心"><a href="#谋心" class="headerlink" title="谋心"></a>谋心</h2><ul><li><strong>《要成就自己，先培养习惯》</strong> 2021/8/21-2021/10/18<br>一本教你养成良好习惯的书，但前提是要静下心来看。查缺补漏，很有帮助。看书期间自己住了次院，也总结了下，很多都是因为自己之前的习惯造成的。</li></ul><h2 id="谋食"><a href="#谋食" class="headerlink" title="谋食"></a>谋食</h2><ul><li><strong>《吃的明白》</strong> 2021/08/14-</li></ul><h2 id="未读"><a href="#未读" class="headerlink" title="未读"></a>未读</h2><ul><li>王阳明全集</li><li>你的生活需要仪式感</li><li>国家地理系列之走遍中国</li><li>好吃易做大众菜</li><li>吃得明白</li><li>Docker技术入门与实战</li></ul>]]></content>
      
      
      <categories>
          
          <category> 读书 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>未读书单</title>
      <link href="2021/03/14/wei-du-shu-dan/"/>
      <url>2021/03/14/wei-du-shu-dan/</url>
      
        <content type="html"><![CDATA[<h1 id="谋生"><a href="#谋生" class="headerlink" title="谋生"></a>谋生</h1><ul><li>Kubernetes 源码剖析 2021年3月20日</li><li>深入浅出Istio</li><li>Docker技术入门与实战</li></ul><h1 id="谋心"><a href="#谋心" class="headerlink" title="谋心"></a>谋心</h1><ul><li>王阳明全集</li><li>你的生活需要仪式感</li><li>国家地理系列之走遍中国</li></ul><h1 id="谋食"><a href="#谋食" class="headerlink" title="谋食"></a>谋食</h1><ul><li>好吃易做大众菜</li><li>吃得明白</li></ul>]]></content>
      
      
      <categories>
          
          <category> 读书 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Pensieve技术架构</title>
      <link href="2021/03/14/pensieve-ji-zhu-jia-gou/"/>
      <url>2021/03/14/pensieve-ji-zhu-jia-gou/</url>
      
        <content type="html"><![CDATA[<h2 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h2><p><img src="/images/pensieve_network.png" alt="Pensieve 网络架构图"><br>如图所示，用户访问阿里云，通过内网穿透工具将请求转发到本地，本地使用Kong来进行流量转发。博客网站Pensieve使用Hexo的Melody主题，需要分享的资源用NextCloud进行永久存储。当然，所有软件皆使用Portainer进行管理。</p><h2 id="硬件"><a href="#硬件" class="headerlink" title="硬件"></a>硬件</h2><ul><li>云服务器：<br>阿里云的2核1G实例5年 ¥437 带宽按量付费 ¥0.08/GB</li><li>树莓派：<br>Raspberry 4B 8G 基础套餐 ¥600</li></ul><h2 id="软件"><a href="#软件" class="headerlink" title="软件"></a>软件</h2><ul><li><a href="https://github.com/ehang-io/nps">NPS&amp;NPC</a>: 一款轻量级、高性能、功能强大的内网穿透代理服务器。支持界面配置</li><li><a href="https://github.com/Kong/kong">Kong</a>: Kong 是在客户端和（微）服务间转发API通信的API网关,配合 <a href="https://github.com/pantsel/konga">Konga</a> 可以实现界面化配置。</li><li><a href="https://github.com/portainer/portainer">Portainer</a>: 一个可视化的容器镜像的图形管理工具</li><li><a href="https://github.com/nextcloud/server">NextCloud</a>: 一款开源免费的私有云存储网盘项目，支持多端访问(有自己的App)</li><li><a href="https://github.com/hexojs/hexo">Hexo</a>: 基于Nodejs 的静态博客网站生成器，简洁却不简单！</li></ul>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 架构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Pensieve </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Pensieve 服务器架构(树莓派单机)</title>
      <link href="2021/03/14/pensieve-shu-mei-pai-dan-ji-jia-gou/"/>
      <url>2021/03/14/pensieve-shu-mei-pai-dan-ji-jia-gou/</url>
      
        <content type="html"><![CDATA[<h2 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h2><p><img src="/images/pensieve_network.png" alt="Pensieve 网络架构图"><br>如图所示，用户访问阿里云，通过内网穿透工具将请求转发到本地，本地使用Kong来进行流量转发。博客网站Pensieve使用Hexo的Melody主题，需要分享的资源用NextCloud进行永久存储。当然，所有软件皆使用Portainer进行管理。</p><h2 id="硬件"><a href="#硬件" class="headerlink" title="硬件"></a>硬件</h2><ul><li>云服务器：<br>阿里云的2核1G实例5年 ¥437 带宽按量付费 ¥0.08/GB</li><li>树莓派：<br>Raspberry 4B 8G 基础套餐 ¥600</li></ul><h2 id="软件"><a href="#软件" class="headerlink" title="软件"></a>软件</h2><ul><li><a href="https://github.com/ehang-io/nps">NPS&amp;NPC</a>: 一款轻量级、高性能、功能强大的内网穿透代理服务器。支持界面配置</li><li><a href="https://github.com/Kong/kong">Kong</a>: Kong 是在客户端和（微）服务间转发API通信的API网关,配合 <a href="https://github.com/pantsel/konga">Konga</a> 可以实现界面化配置。</li><li><a href="https://github.com/portainer/portainer">Portainer</a>: 一个可视化的容器镜像的图形管理工具</li><li><a href="https://github.com/nextcloud/server">NextCloud</a>: 一款开源免费的私有云存储网盘项目，支持多端访问(有自己的App)</li><li><a href="https://github.com/hexojs/hexo">Hexo</a>: 基于Nodejs 的静态博客网站生成器，简洁却不简单！</li></ul>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 架构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Pensieve </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Pensieve软件架构</title>
      <link href="2021/03/14/pensieve-ruan-jian-jia-gou/"/>
      <url>2021/03/14/pensieve-ruan-jian-jia-gou/</url>
      
        <content type="html"><![CDATA[<h2 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h2><p><img src="/images/pensieve_software_secma.png" alt="Pensieve 软件架构图"></p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 架构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Pensieve </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Pensieve —— 献给十年后的自己</title>
      <link href="2021/03/12/pensieve-xian-gei-shi-nian-hou-de-zi-ji/"/>
      <url>2021/03/12/pensieve-xian-gei-shi-nian-hou-de-zi-ji/</url>
      
        <content type="html"><![CDATA[<h2 id="献给十年后的自己"><a href="#献给十年后的自己" class="headerlink" title="献给十年后的自己"></a>献给十年后的自己</h2><p>这已经不是我第一次这么想了！从我毕业那时起，总想着为未来的自己做些什么。我是一个喜欢规划未来的人。<strong>想着只要通过不断的规划，尽可能地把未来的种种放在规划之内，那么接下来发生的事情都是在我可控范围之内的。</strong>看起来还不错！不是吗？</p><p>在2019年1月5日，我买了个本子，打算以此记录自己在工作生活中的学习、想法等（之后也会把这个本子中有用的部分整理在网站中）。 这个本子一直记录到2019年7月2号，因为后来第一家公司经营上发生了一些问题，忙于找下家，找到下家又开始紧张地学习新东西，这个本子便被遗忘了。直到……最近。</p><p>最近入职了PayPal，团队成员都是那么的优秀。虽然是以外包的身份加入的，但仍然感受到了同事的热切关心和细致教导。不论是从做人还是做事，我都从他们身上学到了很多。更重要的是，属于我自己的时间，变得更多了。于是我又拾起了这个计划：以十年为期，献给十年后的自己！在这期间，我会记录我在工作、生活中的点点滴滴，来祭奠我的青春！</p><h2 id="关于Pensieve"><a href="#关于Pensieve" class="headerlink" title="关于Pensieve"></a>关于Pensieve</h2><p>——冥想盆。是《哈利波特》中，邓布利多用来保存头脑中的想法和记忆的不可思议的工具。试问，有哪个男孩子不希望拥有魔法呢？也许在现实生活中，我这只程序猿该被算作 <strong>Mudblood</strong> 吧！</p><p>我希望，我也可以用这样的魔法，来记录生活中的点滴——Pensieve；用魔法，来永远地留住家人——MagicPhoto；用魔法，来改善生活质量——Alohomora。科技，让生活更美好！</p>]]></content>
      
      
      <categories>
          
          <category> 想法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Pensieve </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
